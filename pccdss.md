![](data:image/png;base64,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)

**Payment Card Industry (PCI)**

# Software Security Framework

**Secure Software Requirements and Assessment Procedures**

**Version 1.2.1**

May 2023

## Document Changes

| **Date** | **Version** | **Description** |
| --- | --- | --- |
| January 2019 | 1.0 | Initial release |
| April 2021 | 1.1 | Update from v1.0. See _PCI Software Security Framework – Summary of Changes from Secure Software Requirements and Assessment Procedures Version 1.0 to 1.1_ for details of changes. |
| October 2022 | 1.2 | Update from v1.1. See _PCI Software Security Framework – Summary of Changes from Secure Software Requirements and Assessment Procedures Version 1.1 to 1.2_ for details of changes. |
| May 2023 | 1.2.1 | Update from v1.2 to address errata. |

## Table of Contents

Introduction ..................................................................................................................................................................................................................... 6

Terminology ................................................................................................................................................................................................................ 6

Related Publications ................................................................................................................................................................................................... 7

Stakeholder Roles and Responsibilities ..................................................................................................................................................................... 8

Overview of PCI Secure Standard ................................................................................................................................................................................ 10

Scope of Security Requirements .............................................................................................................................................................................. 10

Requirement Modules ............................................................................................................................................................................................... 11

Requirement Module Applicability ........................................................................................................................................................................ 11

Objective-Based Approach to Requirements............................................................................................................................................................ 12

Requirement Frequency and Rigor....................................................................................................................................................................... 12

Requirement Structure .............................................................................................................................................................................................. 12

Testing Methods........................................................................................................................................................................................................ 13

Reliance on Third-Party Testing ........................................................................................................................................................................... 14

Use of Sampling .................................................................................................................................................................................................... 14

Use of a Test Platform .......................................................................................................................................................................................... 15

Core Requirements ....................................................................................................................................................................................................... 16

Minimizing the Attack Surface................................................................................................................................................................................... 16

Control Objective 1: Critical Asset Identification ................................................................................................................................................... 16

Control Objective 2: Secure Defaults.................................................................................................................................................................... 19

Control Objective 3: Sensitive Data Retention ..................................................................................................................................................... 25

Software Protection Mechanisms ............................................................................................................................................................................. 32

Control Objective 4: Critical Asset Protection ....................................................................................................................................................... 32

Control Objective 5: Authentication and Access Control ...................................................................................................................................... 35

Control Objective 6: Sensitive Data Protection..................................................................................................................................................... 39 Control Objective 7: Use of Cryptography ............................................................................................................................................................ 42

Secure Software Operations ..................................................................................................................................................................................... 49

Control Objective 8: Activity Tracking ................................................................................................................................................................... 49

Control Objective 9: Attack Detection ................................................................................................................................................................... 53

Secure Software Lifecycle Management .................................................................................................................................................................. 55

Control Objective 10: Threat and Vulnerability Management ............................................................................................................................... 55

Control Objective 11: Secure Software Updates .................................................................................................................................................. 57

Control Objective 12: Software Vendor Implementation Guidance ...................................................................................................................... 59

Module A – Account Data Protection Requirements .................................................................................................................................................... 61

Purpose and Scope................................................................................................................................................................................................... 61

Security Requirements .............................................................................................................................................................................................. 63

Control Objective A.1: Sensitive Authentication Data .......................................................................................................................................... 63

Control Objective A.2: Cardholder Data Protection .............................................................................................................................................. 64

Module B – Terminal Software Requirements .............................................................................................................................................................. 67

Purpose and Scope................................................................................................................................................................................................... 67

Background ............................................................................................................................................................................................................... 67

Considerations .......................................................................................................................................................................................................... 68

Security Requirements .............................................................................................................................................................................................. 69

Control Objective B.1: Terminal Software Documentation ................................................................................................................................... 69

Control Objective B.2: Terminal Software Design ................................................................................................................................................ 71

Control Objective B.3: Terminal Software Attack Mitigation ................................................................................................................................. 79

Control Objective B.4: Terminal Software Security Testing ................................................................................................................................. 83

Control Objective B.5: Terminal Software Implementation Guidance .................................................................................................................. 85

Module C – Web Software Requirements .................................................................................................................................................................... 87

Purpose and Scope................................................................................................................................................................................................... 87

Considerations .......................................................................................................................................................................................................... 87 Security Requirements .............................................................................................................................................................................................. 88

Control Objective C.1: Web Software Components & Services ........................................................................................................................... 88

Control Objective C.2: Web Software Access Controls ........................................................................................................................................ 93

Control Objective C.3: Web Software Attack Mitigation ..................................................................................................................................... 100

Control Objective C.4: Web Software Communications ..................................................................................................................................... 109

## Introduction

To ensure reliable and accurate electronic payment transactions, the systems and software used as part of the payment transaction flow must be designed, developed, and maintained in a manner that protects the integrity of payment transactions and the confidentiality of all sensitive data stored, processed, or transmitted in association with payment transactions. This document, the _Payment Card Industry (PCI) Secure Software_

_Requirements and Assessment Procedures_ (hereafter referred to as the “PCI Secure Software Standard” or “this standard”) provides a baseline of security requirements with corresponding assessment procedures and guidance for building secure payment software.

The _PCI Secure Software Standard_ is intended for use as part of the PCI Software Security Framework (SSF). Entities wishing to have their payment software validated under the PCI SSF would do so to this standard.

### Terminology

A list of applicable terms and definitions is provided in the _PCI Software Security Framework Glossary of Terms, Abbreviations, and Acronyms,_ available in the PCI SSC Document Library: [https://www.pcisecuritystandards.org/document_library/.](https://www.pcisecuritystandards.org/document_library/)

Additionally, definitions for general PCI terminology is provided in the PCI Glossary on the PCI SSC website at: [https://www.pcisecuritystandards.org/pci_security/glossary/.](https://www.pcisecuritystandards.org/pci_security/glossary/)

### Related Publications

In addition to the security requirements and assessment procedures for payment software defined in this standard, there are additional documents available to support the use of this standard. For more information, refer to the latest versions of (or successor documents to) the following PCI SSC publications in the PCI SSC Document Library:

| **Document Name** | **Description** |
| --- | --- |
| _PCI Software Security Framework – Technical FAQs for Secure Software_<br><br>_Standard_ (“Secure Software Technical FAQs”) | Technical Frequently Asked Questions (FAQs) provide a mechanism to address questions related to the interpretation and application of the associated PCI Standard and Program. Technical FAQs are considered ‘normative,’ and they must be fully considered within the scope of assessment activity for the associated Standard. |
| _PCI Software Security Framework – PCI Secure Software Lifecycle Standard_<br><br>(“Secure SLC Standard”) | Additional security requirements for software development organizations to ensure they develop and maintain software securely throughout the entire software lifecycle. |
| _PCI Software Security Framework – Glossary of Terms, Abbreviations, and_<br><br>_Acronyms_ (“SSF Glossary”) | Describes important terms, abbreviations, and acronyms used throughout the Secure Software Standard and supporting documentation. |
| _PCI Software Security Framework – Secure Software Program Guide_<br><br>(“Secure Software Program Guide”) | Describes the program requirements for entities to validate their payment software for compliance to the Secure Software Standard and have their software listed and maintained on the PCI SSC’s List of Validated Payment Software. |
| _PCI Software Security Framework – Secure Software Template for Report on_<br><br>_Validation_ (“Secure Software ROV Reporting Template”) | The mandatory template that qualified SSF Assessors must use to document the results of a Secure Software Assessment and report those results to PCI SSC. |
| _PCI Software Security Framework – Secure Software Attestation of Validation_<br><br>(“Secure Software AOV”) | A template document provided by PCI SSC that Secure Software Assessor Companies and Vendors must use to attest to the results of a Secure Software Assessment. |
| _PCI Software Security Framework – Qualification Requirements for Assessors_<br><br>(“SSF Qualification Requirements”) | Describes the minimum capability and related documentation requirements that SSF Assessor Companies and their Assessor-Employees must satisfy to be qualified to perform Secure Software Assessments. |
| _PCI PIN Transaction Security (PTS) Point-of-Interaction (POI) Modular_<br><br>_Security Requirements_ (“PCI PTS POI Standard") | Security requirements that must be met for payment acceptance devices to obtain Payment Card Industry (PCI) PIN Transaction Security (PTS) Point of Interaction (POI) device approval. |
| **Document Name** | **Description** |
| _Vendor Release Agreement_ (“VRA”) | Establishes the terms and conditions that Vendors of Validated Payment Software must meet to participate in PCI Programs. |

### Stakeholder Roles and Responsibilities

There are numerous stakeholders involved in maintaining and managing PCI standards. The following describes the high-level roles and responsibilities of these stakeholders as they relate to the PCI Software Security Framework:

**PCI SSC** – Responsible for maintaining the standards, supporting programs, and related documentation associated with the PCI Software Security Framework including, but not limited to:

- Maintaining the PCI Secure Software Standard (this document).
- Maintaining all supporting documentation including reporting templates, attestation forms, frequently asked questions (FAQs), and guidance to assist entities implementing and assessing to this standard.
- Providing instructions and guidance for SSF Assessors in accordance with the requirements and assessment procedures in this standard.
- Maintaining a list of all SSF Assessors qualified to perform assessments to this standard (on the [PCI SSC Website)](https://www.pcisecuritystandards.org/).
- Maintaining a quality assurance program for SSF Assessors.

**Participating Payment Brands** – Responsible for developing and enforcing their respective compliance programs related to PCI standards including, but not limited to:

- Defining and enforcing requirements, mandates, and deadlines for compliance to the PCI Secure Software Standard (this document).
- Determining the entities that are required to comply with this standard.
- Specifying the validation methods and frequency.
- Identifying and enforcing any fines or penalties for non-compliance.

**SSF Assessor Companies** – Responsible for maintaining the required knowledge, expertise, and equipment necessary to execute all assessment activities, adhering to all SSF Assessor Qualification Requirements, performing assessments to this standard, and generating the assessment report documenting the results. Note that not all SSF Assessor Companies are qualified to perform assessments to this standard. For more information on assessment activities and assessor qualification requirements, refer to the _PCI Secure Software Program Guide_ and _Qualification Requirements for SSF Assessors_, respectively.

**Payment Software Vendors / Providers / Developers** – Responsible for developing, distributing, maintaining, and operating (where applicable) payment software, and ensuring that their payment software meets all applicable security requirements defined in this standard.

## Overview of PCI Secure Software Standard

The security requirements defined within the _PCI Secure Software Standard_ ensure that payment software is designed, engineered, developed, and maintained in a manner that protects payment transactions and data, minimizes vulnerabilities, and defends against attacks.

### Scope of Security Requirements

The security requirements defined in this standard describe the security characteristics, controls, features, and capabilities that payment software must possess to protect the integrity of payment functions and the confidentiality of sensitive payment data. The payment software features that are in scope for these requirements include, but are not limited to:

- All end-to-end payment software functionality, including:

− All payment functions.

− Inputs and outputs.

− Handling of error conditions.

− Interfaces and connections to other files, systems, and/or software.

− Data flows.

− Security mechanisms, controls, and countermeasures, such as authentication, authorization, validation, parameterization, segmentation, logging, and so on.

- Processes used by the software vendor, provider, or developer to identify and support software security controls.
- Guidance that the software vendor, provider, or developer is expected to provide to stakeholders that describes:

− How to implement and operate the payment software securely.

− All configuration options available that can impact the security of payment software, including those of the execution environment and related system components.

− How to implement security updates.

− How and where to report security issues to the software vendor, provider, and/or developer.

_Note that the software vendor, provider, or developer may be expected to provide such guidance even when the specific settings:_

− Cannot be controlled by the payment software vendor, provider, or developer after the software is installed in a production environment.

− Are the responsibility of the implementing entity and not the software vendor, provider, or developer.

- Any other software, software functionality, or services necessary for a full implementation of the payment software, including but not limited to:

− Third-party and open-source software functions, libraries, packages, components, services, and dependencies embedded in or relied upon by the payment software to provide its intended function.

− Features and functions of a supported platform or the execution environment relied upon by the payment software for security purposes.

− Third-party or custom tools and functions relied upon by the payment software to satisfy security requirements in this standard.

### Requirement Modules

The PCI Secure Software Standard includes the concept of requirement “modules,” which are distinct groups of requirements relating to a specific topic or type of software. Modules are intended to clarify how and when specific requirements apply to a given payment application or function.

The requirements in this standard are organized into the following four requirement modules:

- **Core Requirements (“Core Module”)**: General security requirements that apply to all types of payment software regardless of software function, design, or underlying technology.
- **Module A – Account Data Protection Requirements (“Account Data Protection Module”)**: Additional security requirements for payment software that store, process, or transmit account data.
- **Module B – Terminal Software Requirements (“Terminal Software Module”)**: Additional security requirements for payment software specifically designed for deployment and operation on PCI-approved POI devices.
- **Module C – Web Software Requirements (“Web Software Module”)**: Additional security requirements for payment software that uses Internet technologies, protocols, and languages to initiate or support electronic payment transactions.

#### Requirement Module Applicability

Each requirement module includes its own applicability criteria. It is expected that software assessed to this standard will include assessment to all applicable modules. At a minimum, payment software must be assessed to the Core Module. Additional modules are included in the assessment when the software meets the applicability criteria for those additional modules. Refer to the “Purpose and Scope” section within each additional module for more information on module applicability criteria.

Be aware that some requirements defined within individual modules are extensions of Core Module requirements. Where such relationships are noted, the requirements in modules should be assessed in conjunction with their associated “Core” requirements.

Also note that there may be certain requirements defined within a module that are similar to requirements in other modules or that may have broader applicability beyond the module(s) where they are defined. Unless otherwise noted, such requirements are required to be assessed only in the context of that module. With that said, such requirements are likely to be consolidated and/or applied more broadly in future updates to this standard. Entities are encouraged to identify and apply requirements that may be applicable to an entity’s payment software regardless of whether the entity is required to assess to the module where such requirements are defined.

### Objective-Based Approach to Requirements

The PCI Software Security Framework has adopted an “objective-based” approach to defining the security requirements in this standard. The PCI SSC acknowledges that there is no “one size fits all” approach to software security and that software vendors need flexibility to determine the software security controls and features most appropriate to address their specific business needs and risks.

An “objective-based” approach is one that states security requirements as a desired security goal or outcome without necessarily specifying the method(s) to be used to achieve the desired goal. This approach enables entities to implement software security controls based on the risks identified by the software vendor for a given software application. For this approach to be successful, software vendors must possess a robust risk-management practice as an integral part of their software development lifecycle (SDLC) and be able to demonstrate how the implemented security controls are supported by the results of their risk identification and management practices. Without a robust risk-management practice in place and evidence available to support risk-based decision making, adherence to the requirements defined in this standard may be difficult to validate.

#### Requirement Frequency and Rigor

Given the nature of PCI SSC’s objective-based approach to security requirements, many security requirements do not specify the level of rigor or frequency for periodic or recurring activities, such as the maximum period in which a security update must be provided to fix known vulnerabilities. In such cases, the software vendor may define the level of rigor or frequency appropriate for its business needs. The level of rigor or frequency chosen, however, must be supported by documented risk assessments and the resultant risk management decisions. Additionally, the software vendor must demonstrate that its implementation provides ongoing assurance that the software security controls and activities are effective and satisfy all relevant control objectives.

### Requirement Structure

The security requirements defined in this standard are as follows:

- **Control Objectives** – The high-level security objectives that must be met. Control objectives are broadly stated to provide software vendors the flexibility to determine the best method(s) to achieve the stated objective. Regardless of the method(s) chosen, it is expected that the software vendor be able to produce clear and unambiguous evidence to demonstrate that the chosen method(s) is/are appropriate, sufficient, and properly implemented to satisfy the objective.
- **Test Requirements** – The expected assessment activities to be performed by an assessor to determine whether a specific control objective has been met. Test requirements are intended to provide both the software vendor and assessor with a common understanding of the tasks expected to be carried out by the assessor during testing. The specific method(s) used, the item(s) examined, and the personnel interviewed must be appropriate for the control objective being validated and for the software being assessed.
- **Guidance** – Additional information to help payment software vendors and assessors understand the intent of each control objective. The guidance may also include best practices that should be considered and examples of controls or methods that may be used to satisfy the control objective. Guidance is not intended to preclude other methods that a software vendor may use to meet a control objective, nor does it replace or amend the control objective to which it refers.

### Testing Methods

To support the validation of their software to the requirements in this standard, software vendors are expected to produce evidence that they have satisfied the stated control objectives. The test requirements identified for each control objective describe the activities to be performed by the assessor to confirm that the software and/or software vendor have met the control objective(s). Test requirements include the following testing activities:

- **Examine**: The assessor critically evaluates data evidence. Common examples include software design and architecture documents (electronic or physical), source code, configuration and metadata files, bug tracking data and other output from software development systems, and security-testing results. The choice of evidence that may be used to meet an “examination” requirement is deliberately left open for the tester to determine. However, it is a requirement of this standard that the software source code be made available for review as part of the assessment. It is not acceptable for an assessment report to be provided where no source code was examined or used in the process of performing the testing.
- **Interview**: The assessor converses with individual personnel. The purposes of interviews include determining how an activity is performed, whether an activity is performed as defined, and whether personnel have particular knowledge or understanding of applicable policies, processes, responsibilities, or concepts.
- **Test:** The assessor evaluates the software operation to analyze its characteristics and behavior in various scenarios. Unless otherwise stated, software “testing” must include functional testing using forensic tools and techniques. Examples of such tools and techniques include the use of automated static analysis security testing (SAST), dynamic analysis security testing (DAST), interactive application security testing (IAST), and software composition analysis (SCA) tools. Where adversarial testing is explicitly referenced, fuzzing and other penetration testing tools and techniques must be used to try and bypass software security controls or to cause the software to behave in unintended ways.

The specific items or processes to be examined or tested, and the personnel to be interviewed should be appropriate for the control objective being validated and for each entity’s organizational structure, culture, business practices, and software products. It is at the discretion of the assessor to determine the suitability or adequacy of the evidence provided by the entity to support each test requirement. Where bullets are specified in a control objective or test requirement, each bullet is expected to be validated as part of the assessment.

When documenting the assessment results, the assessor identifies the testing activities performed and the result of each activity. While it is expected that an assessor performs all test requirements defined for each control objective, it may also be possible for a control objective to be validated using different or additional testing methods. In such cases, the assessor is expected to document why alternative testing methods were used and how those methods provide at least the same level of assurance as the stated test requirements. Where terms such as “periodic,” “appropriate,” and “reasonable” are used in the test requirement, it is the software providers responsibility to define and defend its decisions regarding the frequency, robustness, and maturity of the implemented controls or processes.

#### Reliance on Third-Party Testing

All test requirements are expected to be performed by the assessor. An assessor may choose, however, to rely on testing performed by a thirdparty to satisfy a test requirement, including the software provider. The assessor retains full responsibility for the testing activities and results, regardless of whether the testing is performed by the assessor, by the software provider, or by a third-party. Where third-party testing is relied upon by the assessor, the assessor must document and justify the following:

▪ How the evidence provided by the third-party supports the same level of rigor as testing performed by the assessor, and ▪ How the assessor verified that the third-party testing relied upon by the assessor is appropriate.

Where an assessed entity’s testing is to be used for the purposes of satisfying test requirements, the assessor must first verify the software vendor is Secure SLC-qualified<sup><sup>[\[1\]](#footnote-1)</sup></sup> before software vendor testing can be relied upon.

#### Use of Sampling

Where appropriate, the assessor may utilize sampling as part of the testing process in accordance with a documented sampling methodology. The assessor’s sampling methodology must detail how samples are chosen and must be provided to PCI SSC upon submission of the Report on Validation (ROV).

Sample selection must include a representative sample of all people, processes, and technologies in scope for the PCI Secure Software assessment. Sample sizes must be sufficiently large to demonstrate that the sample accurately reflects the characteristics of the larger population.

In instances where the assessor’s findings are based on a representative sample rather than the complete set of applicable items, the assessor must explicitly note this fact in the ROV, detail the items chosen as samples for the testing, and provide references to the applicable sections of the assessor’s sampling methodology provided with the ROV. Where the assessor selects samples that do not align with the assessor’s documented sampling methodology, the assessor must provide justification in the ROV for each instance where such samples are used.

#### Use of a Test Platform

To ensure that software testing complies with this standard, it may be necessary for the software vendor to provide a test platform. A test platform is special test functionality that is either separate or absent from production-level code. The test platform must rely on as much of the intended production-level functionality as possible. The test platform serves only to provide a test framework that allows for software functionality to be exercised outside of a production-level deployment environment to verify the software’s compliance to this standard. For example, elevated privileges or access capabilities may need to be granted for the purpose of providing run-time visibility into various facets of the software operation. Other examples include providing a test function to initiate a test transaction or to perform authentication functions. It is at the assessor’s discretion to request any test functionality deemed necessary to verify the software’s compliance with applicable requirements in this standard.

## Core Requirements

### Minimizing the Attack Surface

**_The attack surface of the software is minimized. Confidentiality and integrity of all software critical assets are protected, and all unnecessary features and functions are removed or disabled._**

| **Control Objectives** | **Test Requirements** | **Guidance** |
| --- | --- | --- |
| **Control Objective 1: Critical Asset Identification**<br><br>All software critical assets are identified and classified. |     |     |
| **1.1** All sensitive data stored, processed, or transmitted by the software is identified. | **1.1.a** The assessor shall examine evidence to confirm that information is maintained that details all sensitive data that is stored, processed, and/or transmitted by the software. At a minimum, this shall include all payment data; authentication credentials; cryptographic keys and related data (such as IVs and seed data for random number generators); and system configuration data (such as registry entries, platform environment variables, prompts for plaintext data in software allowing for the entry of PIN data, or configuration scripts). | Software security controls are designed and implemented to protect the confidentiality and/or integrity of critical assets. To make sure these controls are effective and appropriate, the software vendor should identify all sensitive data the software collects, stores, processes, or transmits, as well as all sensitive functions and resources it either provides or uses. |
| **1.1.b** The assessor shall examine evidence to confirm that information is maintained that describes where sensitive data is stored. This includes the storage of sensitive data in temporary storage (such as volatile memory), semi-permanent storage (such as RAM disks), non-volatile storage (such as magnetic and flash storage media), or in specific locations or form factors (such as with an embedded system that is only capable of local storage). |
| **1.1.c** The assessor shall examine evidence to confirm that information is maintained that describes the security controls that are implemented to protect sensitive data. |
| **1.1.d** The assessor shall test the software to validate the evidence obtained in Test Requirements 1.1.a through 1.1.c. |

| **Control Objectives** | **Test Requirements** | **Guidance** |
| --- | --- | --- |
|     | **1.1.e** The assessor shall examine evidence and test the software to identify the transaction types and/or card data elements that are supported by the software, and to confirm that the data for all of these is supported by the evidence examined in Test Requirements 1.1.a through 1.1.c. |     |
| **1.1.f** The assessor shall examine evidence and test the software to identify the cryptographic implementations that are supported by the software (including cryptography used for storage, transport, and authentication), and to confirm that the cryptographic data for all of these implementations is supported by the evidence examined in Test Requirements 1.1.a through 1.1.c, and that the evidence describes whether these are implemented by the software itself, through third-party software, or as functions of the execution environment. |
| **1.1.g** The assessor shall examine evidence and test the software to identify the accounts and authentication credentials supported by the software (including both default and usercreated accounts) and to confirm that these accounts and credentials are supported by the evidence examined in Test<br><br>Requirements 1.1.a through 1.1.c. |
| **1.1.h** The assessor shall examine evidence and test the software to identify the configuration options provided by the software that can impact sensitive data (including those provided through separate files or scripts, internal functions, or menus and options), and to confirm that these are supported by the evidence examined in Test Requirements 1.1.a through 1.1.c. |
| **1.2** All sensitive functions and sensitive resources provided or used by the software are identified. | **1.2.a** The assessor shall examine evidence to confirm that information is maintained that details all sensitive functions and sensitive resources provided or used by the software. At a minimum, this shall include all functions that are designed to store, process, or transmit sensitive data and those services, configuration files, or other information necessary for the normal and secure operation of those functions. |     |

<table><tbody><tr><th><p><strong>Control Objectives</strong></p></th><th colspan="2"><p><strong>Test Requirements</strong></p></th><th></th><th><p><strong>Guidance</strong></p></th></tr><tr><td rowspan="3"><p><strong></strong></p><p><strong></strong></p></td><td colspan="2"><p><strong>1.2.b</strong> The assessor shall examine evidence to confirm that information is maintained that clearly describes how and where the sensitive data associated with these functions and resources is stored. This includes the storage of sensitive data in temporary storage (such as volatile memory), semipermanent storage (such as RAM disks), and non-volatile storage (such as magnetic and flash storage media). The assessor shall confirm that this information is supported by the evidence examined in Test Requirement 1.1.a through 1.1.c.</p></td><td></td><td rowspan="3"><p></p><p></p></td></tr><tr><td colspan="2"><p><strong>1.2.c</strong> Where the sensitive functions or sensitive resources are provided by third-party software or systems, the assessor shall examine evidence and test the software to confirm that the software correctly follows available guidance for the third-party software.</p></td><td rowspan="2"></td></tr><tr><td></td><td><p><strong><em>Note:</em></strong><em> For example, by reviewing the security policy of a PTS or FIPS140-2 or 140-3 approved cryptographic system.</em></p></td></tr><tr><td><p><strong>1.3</strong> Critical assets are classified.<strong></strong></p></td><td colspan="2"><p><strong>1.3 </strong>The assessor shall examine evidence to confirm that:</p><ul><li>The software vendor defines criteria for classifying critical assets in accordance with the confidentiality, integrity, and resiliency requirements for each critical asset.</li><li>An inventory of all critical assets with appropriate classifications is maintained.<strong></strong></li></ul><p><strong></strong></p></td><td></td><td><p>Critical assets represent the sensitive data, functions, and resources that have business value and require confidentiality, integrity, or resiliency protection.</p><p>There are numerous analysis techniques that can be used to identify critical assets, including Mission Impact Analysis (MIA), Functional Dependency</p><p>Network Analysis (FDNA), and Mission Threat Analysis. Additional information and techniques can be found in publications such as the appendices of <em>NIST Special Publication 800-160</em> or in other publications from industry standards bodies such as EMVCo, ISO or ANSI.</p></td></tr></tbody></table>

**Control Objectives Test Requirements Guidance**

**Control Objective 2: Secure Defaults**

Default privileges, features, and functions are restricted to only those necessary to provide a secure default configuration.

**2.1** All functions exposed by the **2.1.a** The assessor shall examine evidence and test the Software often contains functionality (for example, software are enabled by default only software to identify any software APIs or other interfaces that web services, administrative interface, application when and where it is a documented are provided or exposed by default upon installation, heartbeat, etc.) that is optional and is generally

and justified part of the software initialization, or first use. For each of these interfaces, the unused by many users. This functionality typically

architecture. assessor shall confirm that the vendor has documented and does not receive the same attention as standard or justified its use as part of the software architecture. Testing essential software functions and services, and often shall include methods to reveal any exposed interfaces or other contains security weaknesses that can be exploited software functionality (such as scanning for listening services by malicious users to bypass security controls. where applicable). To ensure a secure software deployment, the

**_Note:_** _This includes functions that are auto-enabled as required_ software’s default configuration should only expose _during operation of the software._ functionality that has been reviewed, justified, and

approved. This should include the default

**2.1.b** The assessor shall test the software to determine whether

configuration for all software APIs, protocols, any of the interfaces identified in Test Requirement 2.1.a rely

daemons, listeners, components, etc. on external resources for authentication. Where such resources are relied upon, the assessor shall examine evidence to confirm Any unnecessary services, protocols, or ports that methods are implemented to ensure that proper should be disabled or removed.

authentication remains in place and that these methods are For guidance on services, protocols, or ports included in the assessment of other applicable requirements in considered to be insecure, refer to industry

this standard. standards and guidance (for example, NIST, ENISA,

**2.1.c** The assessor shall test the software to determine whether etc.).

any of the interfaces identified in Test Requirement 2.1.a rely on external resources for the protection of sensitive data during transmission. Where such resources are relied upon, the assessor shall examine evidence to confirm that methods are implemented to ensure proper protection remains in place and that these methods are included in the assessment of other applicable requirements in this standard.

<table><tbody><tr><th><p><strong>Control Objectives</strong></p></th><th colspan="2"><p><strong>Test Requirements</strong></p></th><th></th><th><p><strong>Guidance</strong></p></th></tr><tr><td rowspan="4"><p><strong></strong></p><p><strong></strong></p><p><strong></strong></p></td><td colspan="2"><p><strong>2.1.d</strong> The assessor shall test the software to determine whether any of the interfaces identified in Test Requirement 2.1.a expose functions or services that have publicly disclosed vulnerabilities by conducting a search on the exposed protocols, methods, or services in public vulnerability repositories such as that maintained within the National</p><p>Vulnerability Database.<strong></strong></p></td><td></td><td rowspan="4"><p></p><p></p><p></p></td></tr><tr><td colspan="2"><p><strong>2.1.e</strong> Where known vulnerabilities in exposed interfaces exist, the assessor shall examine evidence and test the software to confirm the following:</p><ul><li>Methods are implemented to mitigate the exploitation of these weaknesses.</li><li>The risks posed by the use of known vulnerable protocols, functions, or ports are documented.</li><li>Clear and sufficient guidance on how to correctly implement sufficient security to meet applicable control objectives in this standard is provided to stakeholders in accordance with Control Objective 12.1.</li></ul></td><td rowspan="2"></td></tr><tr><td></td><td><p><strong><em>Note:</em></strong><em> The assessor</em> <em>should</em> <em>reference the vendor threat information defined in Control Objective 4.1 for this item.</em><strong><em></em></strong></p></td></tr><tr><td colspan="2"><p><strong>2.1.f</strong> The assessor shall examine evidence to identify any thirdparty modules used by the software and to confirm that any such functions exposed by each module are disabled, unable to be accessed through mitigation methods implemented by the software, or formally documented and justified by the software vendor.</p><p>Where access to third-party functions is prevented through implemented protection methods, the assessor shall test the software to confirm that it does not rely on a lack of knowledge of such functions as a security mitigation method by simply not documenting an otherwise accessible API interface and to confirm that the protection methods are effective at preventing the insecure use of such third-party functions.<strong></strong></p></td><td></td></tr></tbody></table>

**Control Objectives**

**Test Requirements**

**Guidance**

**2.2** All software security controls, features, and functions are enabled upon software installation, initialization, or first use.

**_Note:_** _Specific software security controls required to protect the integrity and confidentiality of sensitive data, sensitive functions, and sensitive resources are captured in the Software Protection Mechanisms section._

**2.2.a** The assessor shall examine evidence and test the software to identify all software security controls, features and functions relied upon by the software for the protection of critical assets and to confirm that all are enabled upon installation, initialization, or first use of the software.

As previously noted earlier in guidance, software security controls are designed and implemented to protect the confidentiality and integrity of critical assets. Examples of such software security controls include authentication and authorization mechanisms, cryptographic controls, and controls to prevent leakage of sensitive data.

Default software settings should result in a secure software configuration and should not rely on the end-user being a subject-matter expert to ensure a secure configuration. To that effect, all available software security controls should be active upon software installation, initialization, or first use, depending upon how the software is deployed.

**2.2.b** Where any software security controls, features and functions are enabled only upon initialization or first use, the assessor shall test the software to confirm that sensitive data is processed only after this initialization process is complete.

**2.2.c** Where user input or interaction is required to enable software security controls, features, or functions (such as the installation of certificates), the assessor shall examine evidence to confirm that clear and sufficient guidance on configuring these options is provided to stakeholders in accordance with Control Objective 12.1.

**2.3** Default authentication credentials or keys for built-in accounts are not used after installation, initialization, or first use.

**2.3.a** The assessor shall examine evidence to identify the default credentials, keys, certificates, and other critical assets used for authentication by the software.

To protect against unauthorized access, payment software should prevent the use of built-in accounts until the default authentication credentials can be changed.

_(continued on next page)_

**_Note:_** _The assessor should refer to evidence obtained in the testing of Control Objectives 1, 5, and 7 to determine the authentication and access control mechanisms, keys, and other critical assets used for authentication._

| **Control Objectives** | **Test Requirements** |     |     | **Guidance** |
| --- | --- |     | --- | --- |
|     | **2.3.b** The assessor shall test the software to confirm that all default credentials, keys, certificates, and other critical assets used for authentication by the software are supported by the evidence examined. |     |     | Built-in accounts with known credentials such as default or empty passwords, or default keys are often overlooked during installation, initial configuration, or use, and can be used by a malicious user to bypass access controls. Therefore, the software should not use or rely on the default credentials for its operation upon installation, initialization, or first use. |
|     | **_Note:_** _It is expected that this analysis will include, but not necessarily be limited to, the use of entropy analysis tools to look for hardcoded cryptographic keys, searches for common cryptographic function call and structures such as S-Boxes and big-number library functions (and tracing these functions backwards to search for hardcoded keys), as well as checking for strings containing common user account names or password values._ |
| **2.3.c** Where user input or interaction is required to disable or change any authentication credentials or keys for built-in accounts, the assessor shall examine evidence to confirm that guidance on configuring these options is provided to stakeholders in accordance with Control Objective 12.1. |     |     |
| **2.3.d** The assessor shall test the software to confirm that default authentication credentials or keys for built-in accounts are not used by the authentication and access control mechanisms implemented by the software after software installation, initialization, or first use. |     |     |
|     | **_Note:_** _The assessor should refer to evidence obtained in the testing of Control Objective 5 to determine the authentication and access control mechanisms implemented by the software._ |
| **2.3.e** The assessor shall test the software to confirm that cryptographic keys used for authentication are not used for other purposes, such as protecting sensitive data during storage and transmission. |     |     |
|     | **_Note:_** _The assessor should refer to evidence obtained in the testing of Control Objective 6 to determine the software security controls implemented to protect sensitive data._ |

| **Control Objectives** | **Test Requirements** |     |     | **Guidance** |
| --- | --- |     | --- | --- |
| **2.4** The privileges and resources requested by the software from its execution environment are limited to those necessary for the operation of the software. | **2.4.a** The assessor shall examine evidence to identify the privileges and resources required by the software and to confirm that information is maintained that describes and reasonably justifies all privileges and resources required, including explicit permissions for access to resources, such as cameras, contacts, etc. |     |     | In many attacks on software or underlying systems, the software is often used to execute functions on the underlying operating systems or to abuse accessible external resources. When the software requires excessive permissions, such permissions may be exploited by a malicious user.<br><br>To minimize the software’s attack surface, the software should only request and be granted the minimum required privileges for its intended operation. For example, system service accounts that the software uses to operate, or accounts used by the software to access underlying components such as a database or invoke web-services calls should not require permissions that exceed the minimum necessary for the software to perform its operations.<br><br>The same concept applies to resources used by the software. The software should be granted access to only the minimum required resources for its expected operation. For example, mobile applications that do not require access to the camera or photographs should not request such access unless they are a necessary part of the software architecture. Similarly, software should not have access to sensitive files (for example,<br><br>/etc/passwd) unless there is a legitimate need for the software to access those files. |
| **2.4.b** Where limiting access is not possible due to the architecture of the solution or the execution environment in which the software is executed the assessor shall examine evidence to identify all mechanisms implemented by the software to prevent unauthorized access, exposure, or modification of critical assets, and to confirm that guidance on properly implementing and configuring these mechanisms is provided to stakeholders in accordance with Control Objective 12.1. |     |     |
| **2.4.c** The assessor shall test the software to confirm that access permissions and privileges are assigned according to the evidence examined in Test Requirement 2.4.a. The assessor shall, where possible, use suitable tools for the platform on which the software is installed to review the permissions and privileges of the software itself, as well as the permissions and privileges of any resources, files, or additional elements generated or loaded by the software during use. |     |     |
|     | **_Note:_** _Where the above testing is not possible, the assessor shall justify why this is the case and that the testing that has been performed is sufficient._ |
| **2.4.d** Where the software execution environment provides legacy features for use by older versions of the software, the assessor shall examine evidence and test the software to confirm that these are not used, and that only recent and secured functionality is implemented. For example, software should “target” the latest versions of APIs provided by the environment on which they run, where available. |     |     |

| **Control Objectives** | **Test Requirements** | **Guidance** |
| --- | --- | --- |
| **2.5** Default privileges for built-in accounts are limited to those necessary for their intended purpose and function. | **2.5.a** The assessor shall examine the evidence to identify all default accounts provided by the software and to confirm that the privileges assigned to these accounts are justified and reasonable. | In support of the principle of “least privilege,” built-in accounts should only have the privileges required for the intended function of the account, including access to sensitive data and resources as well as the ability to execute sensitive functions. For example, a built-in administrator account may require the ability to configure the software and associated user accounts, but not the ability to access areas containing sensitive data.<br><br>Applying the principle of least privilege to user accounts helps prevent users without sufficient knowledge about the software from incorrectly or accidentally changing the software configuration or its security settings. Enforcing least privilege also helps to minimize the effects of unauthorized access to software user accounts.<br><br>To limit access to sensitive data, functions, and resources to only those accounts that require such access, the level of privilege and access required should be defined and documented for each built-in account in an access matrix such that its assigned functions may be performed, but no additional or unnecessary access or privileges are granted. |
| **2.5.b** The assessor shall test the software to confirm that all default accounts provided or used by the software are supported by the evidence examined in Test Requirement 2.5.a. |
| **2.5.c** The assessor shall examine evidence and test the software to confirm that exposed interfaces, such as APIs, are protected from attempts by unauthorized users to modify account privileges and elevate user access rights. |

**Control Objectives Test Requirements Guidance**

**Control Objective 3: Sensitive Data Retention**

Retention of sensitive data is minimized.

**3.1** The software only retains the **3.1.a** The assessor shall examine evidence to identify the To prevent the unauthorized disclosure of sensitive sensitive data absolutely necessary sensitive data that is collected by the software for use beyond data to unauthorized parties, the software should for the software to provide its any one transaction, the default time period for which it is retain sensitive data only for the duration necessary intended functionality. retained, and whether the retention period is user-configurable, to perform the specific operation for which sensitive

and to confirm that the purpose for retaining the sensitive data data is collected. Retaining sensitive data longer in this manner is justified and reasonable. than required presents opportunity for the data to be mishandled, misused, or accidentally disclosed.

**_Note:_** _The assessor should refer to evidence obtained in the testing of Control Objective 1.1 to determine the sensitive data_ This control objective differentiates between

_retained by the software._ transient sensitive data retained temporarily and

persistent sensitive data that is retained on a more

**3.1.b** The assessor shall test the software to confirm that all permanent basis. Examples of transient sensitive

available functions or services designed for the retention of data include the retention account data in memory

sensitive data are supported by the evidence examined in Test until payment authorization is received. Examples of

Requirement 3.1.a. persistent sensitive data include the storage of

**_Note:_** _The assessor should refer to evidence obtained in the_ account data on disk to support recurrent payment _testing of Control Objective 1.2 to determine the sensitive_ transactions. _functions and services provided or used by the software._

**3.1.c** The assessor shall examine evidence and test the

software to determine whether the software facilitates the storage of persistent sensitive data for the purposes of debugging, error finding or testing of systems, and to confirm that such data is protected during storage in accordance with Control Objective 6.1. Any function that allows for the storage of sensitive data for these purposes must be explicitly enabled through an interface that requires interaction and authorization by the user and retains the data only for the duration necessary in accordance with reasonable vendor criteria. Closure of the software must result in termination of this debugging state, such that it requires explicit re-enablement when the software is next executed, and any sensitive data is securely deleted per Control Objective 3.4.

| **Control Objectives** | **Test Requirements** | **Guidance** |
| --- | --- | --- |
|     | **3.1**.**d** Where user input or interaction is required to configure the retention period of sensitive data, the assessor shall examine evidence to confirm that guidance on configuring these options is provided to stakeholders in accordance with Control Objective 12.1. |     |
| **3.2** Transient sensitive data is retained only for the duration necessary to fulfill a legitimate business purpose. | **3.2.a** Using information obtained in Test Requirement 1.1.a, the assessor shall examine evidence to identify all sensitive data that is retained by the software for transient use, what triggers the secure deletion of this data, and to confirm that the purposes for retaining the data are justified and reasonable. This includes data that is stored only in memory during the operation of the software. | Sensitive data elements collected in conjunction with software operations should only be retained for as long as required to complete that operation or related transaction.<br><br>After payment processing is complete, all transient sensitive data should be securely deleted from all locations where it has been retained such that any subsequent process, component, function, application, or user within the environment may not access or capture the sensitive data.<br><br>Software vendors should also be aware of and account for how other aspects of the software architecture (such as the software-development language and operating environment) may affect how and where transient sensitive data is retained. For example, operating-system usage of swap partitions or virtual memory files can cause information that should have been transient to persist longer than intended.<br><br>If any sensitive data must be used for debugging or troubleshooting purposes, the software should only capture the minimum amount of data necessary and store it securely in a known location. |
| **3.2.b** Using information obtained in Test Requirement 1.2.a, the assessor shall test the software to confirm that all available functions or services that retain transient sensitive data are supported by evidence examined in Test Requirement 3.2.a and do not use immutable objects. |
| **3.2.c** The assessor shall examine evidence and test the software to determine whether the software facilitates the storage of transient sensitive data for the purposes of debugging, error finding or testing of systems, and to confirm that such data is protected in accordance with Control Objective<br><br>6.1. Any function that allows for the storage of transient sensitive data for these purposes must be explicitly enabled through an interface that requires interaction and authorization by the user. Closure of the software must result in the termination of this debugging state, such that it requires explicit re-enablement when the software is next executed, and any transient sensitive data is securely deleted in accordance with Control Objective 3.5. |

**Control Objectives**

**Test Requirements**

**Guidance**

**3.2.d** Where the retention of transient sensitive data requires user input or interaction, the assessor shall examine evidence to confirm that guidance on configuring these options is provided to stakeholders in accordance with Control Objective 12.1.

**3.3** The software protects the confidentiality and integrity of sensitive data (both transient and persistent) during retention.

**_Note:_** _The Software Protection Mechanisms section includes several specific software security controls that are required to be implemented to protect sensitive data during storage, processing, or transmission. Those software security controls should be analyzed to determine their applicability to the types of sensitive data retained by the software._

**3.3.a** The assessor shall examine the evidence to identify the methods implemented to protect sensitive data during storage.

The software should maintain security controls and mechanisms to protect all sensitive data while it is retained by the software. Examples of software security controls include writing to a secure memory location or using cryptography to render the data unreadable.

**3.3.b** Where sensitive data is stored outside of temporary variables within the code itself, the assessor shall test the software to confirm that sensitive data is protected using either strong cryptography or other methods that provide an equivalent level of security.

**3.3.c** Where protection methods use cryptography, the assessor shall examine evidence and test the software to confirm that the cryptographic implementation complies with Control Objective 7 of this standard.

**3.3.d** Where sensitive data is protected using methods other than strong cryptography, the assessor shall examine evidence and test the software to confirm that the protections are present in all environments where the software is designed to be executed and are implemented correctly.

**3.3.e** Where user input or interaction is required to configure protection methods, the assessor shall examine evidence to confirm that guidance on configuring these options is provided to stakeholders in accordance with Control Objective 12.1.

| **Control Objectives** | **Test Requirements** |     |     | **Guidance** |
| --- | --- |     | --- | --- |
| **3.4** The software securely deletes persistent sensitive data when it is no longer required. | **3.4.a** The assessor shall examine evidence to identify the methods implemented to render persistent sensitive data irretrievable and to confirm that sensitive data is rendered unrecoverable after the process is complete. |     |     | Secure deletion is the process of rendering data irretrievable to other people, processes, or systems.<br><br>Secure deletion may be required at the end of a software-specific operation or upon completion of user-specified retention requirements. In the latter case, the software should be able to securely delete the sensitive data after expiry of the user-specified retention period.<br><br>Only in circumstances where the retention of sensitive data is explicitly permitted should the data be retained after transaction processing is complete. |
| **3.4.b** The assessor shall examine evidence and test the software to identify any platform or implementation level issues that complicate the secure deletion of non-transient sensitive data and to confirm that any non-transient sensitive data is securely deleted using a method that ensures that the data is rendered unrecoverable. Methods may include (but are not necessarily limited to) overwriting the data, deletion of cryptographic keys (of sufficient strength) that have been used to encrypt the data, or platform-specific functions that provide for secure deletion. Methods must accommodate for platformspecific issues, such as flash wear-levelling algorithms or SSD over-provisioning, which may complicate simple over-writing methods. |     |     |
| **3.4.c** The assessor shall test the software using forensic tools to identify any non-transient sensitive data residue in the execution environment, and to confirm that the methods attested by the software vendor are correctly implemented and applied to all sensitive data. This analysis should accommodate for the data structures and methods used to store the sensitive data (for example, by examining file systems at the allocation level and translating data formats to identify sensitive data elements) and cover all non-transient sensitive data types. |     |     |
|     | **_Note:_** _Where forensic testing of some or all aspects of the platform is not possible, the assessor should examine additional evidence to confirm secure deletion of sensitive data. Such evidence may include (but is not necessarily limited to) memory and storage dumps from development systems, evidence from memory traces from emulated systems, or evidence from physical extraction of data performed on-site by the software vendor._ |

| **Control Objectives** | **Test Requirements** |     |     | **Guidance** |
| --- | --- |     | --- | --- |
| **3.5** Transient sensitive data is securely deleted from temporary storage facilities automatically by the software once the purpose for which it is retained is satisfied. | **3.5.a** The assessor shall examine evidence to identify the methods implemented to render transient sensitive data irretrievable and to confirm that sensitive data is unrecoverable after the process is complete. |     |     | Where sensitive data is only retained temporarily to perform a specific function (such as a payment transaction), mechanisms are required to securely delete the sensitive data once the specific function has completed.<br><br>Transient sensitive data is often erased from temporary storage locations after processing is complete. However, that data may remain resident in volatile memory (RAM) or in other storage locations for longer periods than anticipated (such as in swap files/partitions or log files).<br><br>Software vendors should account for all locations where sensitive data is stored, regardless of the intended duration of storage, and ensure that such data is securely deleted once the purpose for which the software collected the data has been satisfied. |
|     | **_Note:_** _This includes data which may be stored only temporarily in program memory / variables during operation of the software._ |
| **3.5.b** The assessor shall examine evidence and test the software to identify any platform or implementation level issues that complicate the erasure of such transient sensitive data such as abstraction layers between the code and the hardware execution environment and to confirm that methods have been implemented to minimize the risk posed by these complications. |     |     |
| **3.5.c** The assessor shall test the software to identify any sensitive data residue in the execution environment and to confirm that the methods implemented are implemented correctly and enforced for all transient sensitive data. This analysis should accommodate for the data structures and methods used to store the sensitive data (for example, by examining file systems at the allocation level and translating data formats to identify sensitive data elements) and cover all non-transient sensitive data types. |     |     |
|     | **_Note:_** _Where forensic testing of some or all aspects of the platform is not possible, the assessor should examine additional evidence to confirm secure deletion of sensitive data. Such evidence may include (but is not necessarily limited to) memory and storage dumps from development systems, evidence from memory traces from emulated systems, or evidence from physical extraction of data performed on-site by the software vendor._ |

<table><tbody><tr><th><p><strong>Control Objectives</strong></p></th><th><p><strong>Test Requirements</strong></p></th><th><p><strong>Guidance</strong></p></th></tr><tr><td rowspan="3"><p><strong>3.6 </strong>The software does not disclose sensitive data through unintended channels.<strong></strong></p><p><strong></strong></p><p><strong></strong></p></td><td><p><strong>3.6.a </strong>The assessor shall examine evidence to confirm the software vendor has performed a thorough analysis to account for all sensitive data disclosure attack vectors including, but not limited to:</p><ul><li>Error messages, error logs, or memory dumps.</li><li>Execution environments that may be vulnerable to remote side-channel attacks to expose sensitive data, such as attacks that exploit cache timing or branch prediction within the platform processor.</li><li>Automatic storage or exposure of sensitive data by the underlying execution environment, such as through swapfiles, system error logging, keyboard spelling, and autocorrect features.</li><li>Sensors or services provided by the execution environment that may be used to extract or leak sensitive data, such as through use of an accelerometer to capture input of a passphrase to be used as a seed for a cryptographic key, or through capture of sensitive data through use of cameras or near-field communication (NFC) interfaces.<strong></strong></li></ul></td><td rowspan="3"><p>Proactive measures to ensure that sensitive data is not inadvertently “leaked” should be implemented by the software vendor or within the software.</p><p>Disclosure of sensitive data to unauthorized parties often occurs through unknown or unintended outputs or channels. For example: sensitive data could be unintentionally disclosed through error- or exceptionhandling routines, logging or debugging channels, third-party services and/or components, or through the use of shared resources such as memory, disk, files, keyboards, displays, and functions.</p><p>Protective mechanisms, whether process or programmatic in nature, should be implemented to ensure that sensitive data is not accidentally disclosed through such means.</p><p></p><p></p></td></tr><tr><td><p><strong>3.6.b</strong> The assessor shall examine evidence, including the results of the analysis described in Test Requirement 3.6.a, and test the software to confirm that methods are implemented to protect against unintended disclosure of sensitive data. Such methods may include usage of cryptography to protect the data, or the use of blinding or masking of cryptographic operations (where supported by the execution environment).<strong></strong></p></td></tr><tr><td><p><strong>3.6.c</strong> Where protection methods require user input or interaction, the assessor shall examine evidence to confirm that guidance on the proper configuration and use of such methods</p><p>is provided to stakeholders in accordance with Control Objective 12.1.<strong></strong></p></td></tr><tr><td><p><strong>Control Objectives</strong></p></td><td><p><strong>Test Requirements</strong></p></td><td><p><strong>Guidance</strong></p></td></tr><tr><td><p><strong></strong></p></td><td><p><strong>3.6.d </strong>The assessor shall test the software to identify any sensitive data residue in the execution environment, and to confirm that protection methods are implemented correctly and the software does not expose or otherwise reveal sensitive data to unauthorized users.<strong></strong></p></td><td><p></p></td></tr></tbody></table>

### Software Protection Mechanisms

**_Software security controls are implemented to protect the integrity and confidentiality of critical assets._**

**Control Objectives**

**Test Requirements**

**Guidance**

**Control Objective 4: Critical Asset Protection**

Critical assets are protected from attack scenarios.

**4.1** Attack scenarios applicable to the software are identified.

**_Note:_** _This control objective is an extension of Control Objective 10.1. Validation of both control objectives should be performed at the same time._

**4.1.a** The assessor shall examine evidence to confirm that the software vendor has identified and documented relevant attack scenarios for the software.

Software vendors should evaluate the design of their payment software to identify attack scenarios applicable to the software and should document the results of that analysis. Documentation should describe the various aspects of the code that could be attacked (including tasks or actions that frameworks and libraries do on the software’s behalf), the difficulty in mounting a successful attack, the mitigation techniques used to protect against such attacks, and the methodology used for measuring the likelihood and impact of each potential attack method.

When the software relies on execution environment security controls, the software vendor should review and reference the implementation documentation for the platform (such as Security Policies for PCIapproved POI devices or FIPS140-2 or 140-3 approved cryptographic modules) and should confirm that the software and its associated documentation correctly and completely accommodate the guidance in these documents.

**4.1.b** The assessor shall examine evidence to determine whether any specific industry-standard methods or guidelines were used to identify relevant attack scenarios.

Where such industry standards are not used, the assessor shall confirm that the methodology used provides equivalent coverage for the attack scenarios applicable to the software under evaluation.

<table><tbody><tr><th><p><strong>Control Objectives</strong></p></th><th><p><strong>Test Requirements</strong></p></th><th><p><strong>Guidance</strong></p></th></tr><tr><td><p><strong></strong></p><p><strong></strong></p></td><td><p><strong>4.1.c </strong>The assessor shall examine evidence to confirm the following:</p><ul><li>A formal owner of the software is assigned. This may be a role for a specific individual or a specific name, but evidence must clearly show an individual who is accountable for the security of the software.</li><li>A methodology is defined for measuring the likelihood and impact for any exploit of the system.</li><li>Generic threat methods and types that may be applicable to the software are documented.</li><li>All critical assets managed, and all sensitive resources used by the system are documented.<em></em></li><li>All entry and egress points for sensitive data, as well as the authentication and trust model applied to each of these entry/egress points, are documented.</li><li>All data flows, network segments, and authentication/privilege boundaries are documented.</li><li>All static IPs, domains, URLs, or ports required by the software for operation are documented.</li><li>Considerations for cryptography elements like cipher modes, and protecting against relevant attacks such as timing attacks, padded oracles, brute force, “rainbow table” attacks, and dictionary attacks against the input domain are documented.</li><li>Execution environment implementation specifics or assumptions, such as network configurations and operating system security configurations, are documented.</li><li>Considerations for the software execution environment, the size of the install base, and the attack surfaces that must be mitigated are documented. Examples of such attack surfaces may include insecure user prompts or protocol stacks, or the storage of sensitive data post authorization or using insecure methods.<em></em></li></ul></td><td><p></p><p></p></td></tr></tbody></table>

| **Control Objectives** | **Test Requirements** | **Guidance** |
| --- | --- | --- |
| **4.2** Software security controls are implemented to mitigate software attacks. | **4.2.a** The assessor shall examine evidence to confirm that one or more mitigation methods are defined for each of the threats identified in Test Requirement 4.1.a or that justification for the lack of mitigations is provided. | Once attack scenarios are identified, the risk of their occurrence should be mitigated. Software vendors should define and implement mechanisms to protect the software from attacks and reduce the likelihood and impact of successful execution. Any attack scenarios left unmitigated or insufficiently mitigated should be reasonably justified.<br><br>The exact nature of the protection mechanism(s) will depend on the attack scenarios, the development platform, and the software-development languages, frameworks, libraries, and APIs used by the software, as well as the execution environment where the software is intended to be deployed.<br><br>To minimize the software attack surface, the software should be developed using secure design principles such as layered defense, application segmentation and isolation (logical), and adaptive response.<br><br>Examples of software security controls include input and output validation, authentication, parameterization, escaping, segmentation, logging, etc. For guidance on implementing cyber resiliency techniques and approaches, refer to industry standards and guidance such as the current version of _NIST Special Publication 800-160_. |
| **4.2.b** Where any mitigations rely on settings within the software, the assessor shall test the software to confirm that such settings are applied by default upon installation, initialization, or first use of the software. |
| **4.2.c** Where user input or interaction can disable, remove, or bypass any such mitigations, the assessor shall examine evidence and test the software to confirm that such action requires authentication and authorization and that guidance on the risk of such actions is provided to stakeholders in accordance with Control Objective 12.1. |
| **4.2.d** When any mitigations rely on features of the execution environment, the assessor shall examine evidence to confirm that guidance is provided to stakeholders on how to enable such settings in accordance with Control Objective 12.1. |
| **4.2.e** Where the execution environment provides APIs to query the status of mitigation controls, the assessor shall test the software to confirm that software checks for these mitigations are in place and active prior to being launched and periodically throughout execution. |

<table><tbody><tr><th><p><strong>Control Objectives</strong></p></th><th colspan="3"><p><strong>Test Requirements</strong></p></th><th><p><strong>Guidance</strong></p></th></tr><tr><td colspan="5"><p><strong>Control Objective 5: Authentication and Access Control</strong></p><p>The software implements robust authentication and access control methods to protect the confidentiality, integrity, and resiliency of critical assets.<strong></strong></p></td></tr><tr><td rowspan="4"><p><strong>5.1</strong> Access to critical assets is authenticated.</p><p><strong></strong></p><p><strong></strong></p></td><td colspan="3"><p><strong>5.1.a </strong>The assessor shall examine evidence to confirm that authentication requirements are defined (i.e., type and number of factors) for all roles based on critical asset classification, the type of access (e.g., local, non-console, remote) and level of privilege.</p></td><td rowspan="4"><p>Secure authentication ensures individual responsibility for actions and allows the software to maintain an effective audit trail of user activity. This expedites issue resolution and containment when the software is misused for malicious purposes.</p><p>Authentication mechanisms should cover all nonpublic resources managed by or accessible through the software, as well as sensitive functions that can alter the software operation or impact the security of sensitive data and sensitive resources. Examples of authentication methods include:</p><ul><li>Something you know, such as a password or passphrase.</li><li>Something you have, such as a token device or smart card.</li><li>Something you are, such as a biometric.</li></ul><p>To ensure that the implemented authentication mechanisms are adequate to address the risk of unauthorized access to sensitive data or sensitive resources, or misuse of a sensitive function, the vendor should analyze threats and identify the required level of authentication for all types of users and roles.</p><p>For example, a user with limited access to sensitive data and sensitive resources could be required to perform authentication using a single authentication factor (for example, a password or a passphrase) while a user that is able to export the entire database might be required to perform multi-factor authentication.<em></em></p><p><em>(continued on next page)</em></p></td></tr><tr><td></td><td><p><strong><em>Note:</em></strong><em> The assessor should refer to evidence obtained in the testing of Control Objective 1.3 to determine the classifications for all critical assets.</em></p></td><td></td></tr><tr><td colspan="3"><p><strong>5.1.b </strong>The assessor shall examine evidence and test the software to confirm that access to critical assets is authenticated and authentication mechanisms are implemented correctly.</p></td></tr><tr><td colspan="3"><p><strong>5.1.c </strong>Where the software recommends, suggests, relies on, or otherwise supports the use of external mechanisms (such as third-party VPNs, remote desktop features, etc.) to provide secure non-console access to the system on which the software is executed or directly to the software itself, the assessor shall examine evidence to confirm that guidance on how to configure authentication mechanisms correctly is provided to stakeholders in accordance with Control Objective 12.1.</p></td></tr></tbody></table>

| **Control Objectives** | **Test Requirements** | **Guidance** |
| --- | --- | --- |
|     | **5.1.d** The assessor shall examine evidence to confirm that sensitive data associated with authentication credentials, including public keys, is identified as a critical asset. | Other factors such as the type of access (for example, local, non-console, or remote access) and the level of privilege (for example, the ability to invoke sensitive functions such as pause logging or change access privileges) may influence the level of authentication that should be required. |
| **5.2** Access to critical assets requires unique identification. | **5.2.a** The assessor shall examine evidence and test the software to confirm that all implemented authentication methods require unique identification. | The software should not require the use of any group, shared, or generic accounts. The use of group or shared accounts makes it more difficult to determine which individuals execute specific actions since a given action could have been performed by anyone that has knowledge of the group or shared accounts’ authentication credentials. |
| **5.2.b** Where interfaces, such as APIs, allow for automated access to critical assets, the assessor shall examine evidence and test the software to confirm that unique identification of different programs or systems accessing the critical assets is required (for example, through use of multiple public keys) and that guidance on configuring a unique credential for each program or system is provided to stakeholders in accordance with Control Objective 12.1. |
| **5.2.c** Where identification is supplied across a non-console interface, the assessor shall test the software to confirm that authentication credentials are protected from attacks that attempt to intercept them in transit. |
| **5.2.d** The assessor shall examine evidence to confirm that the guidance provided to stakeholders per Control Objective 12.1 specifically notes that identification and authentication parameters must not be shared between individuals, programs, or in any way that prevents the unique identification of each access to a critical asset. |

| **Control Objectives** | **Test Requirements** |     |     | **Guidance** |
| --- | --- |     | --- | --- |
| **5.3** Authentication methods (including session credentials) are sufficiently strong and robust to protect authentication credentials from being forged, spoofed, leaked, guessed, or circumvented. | **5.3.a** Using information obtained in Test Requirement 4.1.a, the assessor shall examine evidence to confirm that authentication methods implemented by the software are evaluated to identify known vulnerabilities or attack methods involving the authentication method and how the implementation of these methods mitigates against such attacks. The assessor shall also confirm that the evidence examined demonstrates the implementation used in the software was considered. For example, a fingerprint may be uniquely identifiable to an individual, but the ability to spoof or otherwise bypass such technology can be highly dependent on the way the solution is implemented. |     |     | The software vendor must evaluate, document, and justify the usage of implemented authentication methods to demonstrate that they are sufficiently strong to protect authentication credentials in the software’s intended specific use case or deployment scenario.<br><br>For example, if the software uses biometric authentication, the vendor may want to identify all points at which a malicious user may attack the authenticator and implement mitigations to address those risks. The authentication mechanism implemented in the software could rely on additional sensors to ensure the provided biometric sample is from a living human and not a forged or spoofed sample.<br><br>In some use cases or deployment scenarios, an authentication mechanism that relies on a single authentication method may not be sufficient. In such circumstances, the software vendor may want to implement additional mitigation strategies (for example, multi-factor authentication mechanism).<br><br>To support a claim that the implemented authentication mechanism is sufficiently strong and robust, a vendor should adopt an industry-accepted methodology for assigning assurance levels (for example, _NIST SP800-63-3_ and _NIST SP800-63B_). |
| **5.3.b** The assessor shall examine evidence to confirm that the implemented authentication methods are robust and the robustness of the authentication methods was evaluated using industry-accepted methods. |     |     |
|     | **_Note:_** _The vendor assessment and robustness justification include consideration of the full path of the user credentials, from any input source (such as a Human Machine Interface or other program), through transition to the execution environment of the software (including any switched/network transmissions and traversal through the execution environment’s software stack before being processed by the software itself)._ |
| **5.3.c** The assessor shall test the software to confirm that the authentication methods are implemented correctly and do not expose vulnerabilities. |     |     |

| **Control Objectives** | **Test Requirements** | **Guidance** |
| --- | --- | --- |
| **5.4** By default, all access to critical assets is restricted to only those accounts and services that require such access. | **5.4.a** The assessor shall examine evidence to confirm that information is maintained that identifies and justifies the required access for all critical assets. | To ensure the software protects the confidentiality and integrity of critical assets, access privileges to those critical assets should be restricted based on vendordefined access requirements. There are various approaches to implementing privilege restriction, such as trust-based privilege management, attribute-based usage restriction, and dynamic privileges. To reduce the attack surface of the software, the software authorization mechanisms might limit access to critical assets to only those accounts that need such access (the principle of “least privilege”). Other techniques include implementation of Role-Based Access Control (RBAC), Attribute-Based Access Control (ABAC), time-based adjustment to privilege, and dynamic revocation of access authorization. |
| **5.4.b** The assessor shall examine evidence and test the software to identify the level of access that is provided to critical assets and to confirm that such access correlates with the evidence examined in Test Requirement 5.4.a. Testing to confirm access to critical assets is properly restricted should include attempts to access critical assets through user accounts, roles, or services which should not have the required privileges. |

| **Control Objectives** |     | **Test Requirements** |     |     | **Guidance** |
| --- |     | --- |     | --- | --- |
|     | **Control Objective 6: Sensitive Data Protection** Sensitive data is protected at rest and in transit. |     |     |     |     |
| **6.1** Sensitive data is secured anywhere it is stored. |     | **6.1.a** The assessor shall examine evidence to confirm that protection requirements for all sensitive data are defined, including requirements for rendering sensitive data with confidentiality considerations unreadable anywhere it is stored persistently. |     |     | Sensitive data must be protected wherever it is stored. In some cases, the integrity may be the primary concern. In other cases, it may be the confidentiality of the sensitive data that must be protected. Sometimes, both the integrity and confidentiality must be secured. The type of data and the purpose for which it is generated will often determine the need for integrity or confidentiality protection. In all cases, those protection requirements must be clearly defined.<br><br>In cases where the confidentiality of sensitive data is a concern, it is imperative to know where and for how long the data is retained. The vendor must have details of all locations where the software may store sensitive data, including in any underlying software or systems, and documentation detailing the security controls used to protect the data.<br><br>Sensitive data requiring confidentiality protection, when stored persistently, must be protected to prevent malicious or accidental access. Examples of methods to render sensitive data unreadable include usage of a one-way hash or the use of strong cryptography with associated key-management processes.<br><br>_(continued on next page)_ |
| **6.1.b** The assessor shall examine evidence and test the software to confirm that security controls are implemented to protect sensitive data during storage and that they address all defined protection requirements and identified attack scenarios. |     |     |
|     | **_Note:_** _The assessor should refer to evidence obtained in the testing of Control Objective 1.1 to determine all sensitive data retained by the software, and Control Objective 4.1 to identify all attack scenarios applicable to the software._ |
| **6.1.c** Where cryptography is used for securing sensitive data, the assessor shall examine evidence and test the software to confirm that methods implementing cryptography for securing sensitive data comply with Control Objective 7. |     |     |
| **6.1.d** Where index tokens are used for securing sensitive data, the assessor shall examine evidence and test the software to confirm that these are generated in a way that ensures there is no correlation between the value and the sensitive data that is being referenced (without access to the software to perform the correlation as part of a formally defined and assessed feature of that software, such as “de-tokenization”). |     |     |

| **Control Objectives** | **Test Requirements** |     |     | **Guidance** |
| --- | --- |     | --- | --- |
|     | **6.1.e** Where protection methods rely on the security properties of the execution environment, the assessor shall examine evidence and test the software to confirm that these security properties are valid for all platforms where the software is intended to be deployed. |     |     | Where the integrity of sensitive data is a concern, strong cryptography with appropriate key-management practices is one method that could be used to satisfy integrity protection requirements during storage. |
| **6.1.f** Where protection methods rely on the security properties of third-party software, the assessor shall examine evidence and test the software to confirm that there are no unmitigated vulnerabilities or issues with the software providing the security properties. |     |     |
| **6.2** Sensitive data is secured during transmission. | **6.2.a** The assessor shall examine evidence to identify the locations within the software where sensitive data is transmitted outside of the physical execution environment and to confirm protection requirements for the transmission of all sensitive data are defined. |     |     | To prevent malicious individuals from intercepting or diverting sensitive data while in transit, it must be protected during transmission.<br><br>One method to protect sensitive data in transit is to encrypt it using strong cryptography prior to transmission.<br><br>Alternatively, the software could establish an authenticated and encrypted channel using only trusted keys and certificates (for authentication) and appropriate encryption strength for the selected protocols. |
| **6.2.b** The assessor shall examine evidence and test the software to confirm that for each of the ingress and egress methods that allow for transmission of sensitive data outside of the physical execution environment, the data is encrypted with strong cryptography prior to transmission or is transmitted over an encrypted channel using strong cryptography. |     |     |
|     | **_Note:_** _The assessor should refer to evidence obtained in the testing of Control Objective 1.1 to determine the sensitive data stored, processed, or transmitted by the software._ |
| **6.2.c** Where third-party or execution-environment features are relied upon for the security of the transmitted data, the assessor shall examine evidence to confirm that guidance on how to configure such features is provided to stakeholders in accordance with Control Objective 12.1. |     |     |

| **Control Objectives** | **Test Requirements** |     |     | **Guidance** |
| --- | --- |     | --- | --- |
|     | **6.2.d** Where transport layer encryption is used to secure the transmission of sensitive data, the assessor shall examine evidence and test the software to confirm that all ingress and egress methods enforce a secure version of the protocol with end-point authentication prior to transmission. |     |     |     |
| **6.2.e** Where the methods implemented for encrypting sensitive data allow for the use of different types of cryptography or different levels of security, the assessor shall examine evidence and test the software, including capturing software transmissions, to confirm the software enforces the use of strong cryptography at all times during transmission. |     |     |
| **6.3** Use of cryptography meets all applicable cryptography requirements within this standard. | **6.3.a** Where cryptography is relied upon (in whole or in part) for the security of critical assets, the assessor shall examine evidence and test the software to confirm that the use of cryptography is compliant to Control Objective 7. |     |     | Wherever cryptography is used to meet software security requirements in this standard, it must be done in accordance with the specific security requirements related to the use of cryptography (including those in Control Objective 7).<br><br>For example, storing a cryptographic key used for protecting sensitive data in a plaintext file would not be considered sufficient security unless additional controls are implemented to prevent the file containing the cryptographic key from being accessed or modified by, or exposed to unauthorized parties.<br><br>Further guidance on appropriate uses of cryptographic algorithms can be found in current versions of _NIST SP 800-175_ or in other related industry guidance from ISO or ANSI. |
|     | **_Note:_** _The assessor should refer to Control Objective 7 to identify all requirements for appropriate and correct implementation of cryptography._ |
| **6.3.b** Where cryptographic methods provided by third-party software or aspects of the execution environment or platform on which the application is run are relied upon for the protection of sensitive data, the assessor shall examine evidence and test the software to confirm that guidance on configuring these methods during the installation, initialization, or first use of the software is provided to stakeholders in accordance with Control Objective 12.1. |     |     |
| **6.3.c** Where asymmetric cryptography such as RSA or ECC is used for protecting the confidentiality of sensitive data, the assessor shall examine evidence and test the software to confirm that private keys are not used for providing confidentiality protection to the data. |     |     |

<table><tbody><tr><th colspan="2"><p><strong>Control Objectives</strong></p></th><th><p><strong>Test Requirements</strong></p></th><th><p><strong>Guidance</strong></p></th></tr><tr><td></td><td colspan="3"><p><strong>Control Objective 7: Use of Cryptography</strong></p><p>Cryptography is used appropriately and correctly.<strong></strong></p></td></tr><tr><td colspan="2" rowspan="3"><p><strong>7.1 </strong>Industry-standard cryptographic algorithms and methods are used for securing critical assets. Industrystandard cryptographic algorithms and methods are those recognized by industry-accepted standards bodies such as NIST, ANSI, ISO, and EMVCo. Cryptographic algorithms and parameters that are known to be vulnerable are not used.<strong></strong></p><p><strong></strong></p><p><strong></strong></p></td><td><p><strong>7.1.a </strong>The assessor shall examine evidence to determine how cryptography is used for the protection of critical assets and to confirm that:</p><ul><li>Industry-standard cryptographic algorithms and modes of operation are used.</li><li>The use of any other algorithms is in conjunction with industry-standard algorithms.</li><li>The implementation of non-standard algorithms does not reduce the equivalent cryptographic key strength provided by the industry-standard algorithms.</li></ul></td><td rowspan="3"><p>Not all cryptographic algorithms are sufficient to protect sensitive data. It is a well-established principle in software security to utilize only recognized cryptographic implementations based on current, industry-accepted standards such as those from industry bodies like NIST, ANSI, ISO, and EMVCo.</p><p>The use of proprietary cryptographic implementations may increase the risk of data compromise as proprietary implementations are often not subjected to the same level of testing that industry-accepted implementations have undergone. Only those implementations that have been subjected to sufficient testing (for example, by NIST, ANSI, or other recognized industry bodies) should be used.</p><p></p></td></tr><tr><td><p><strong>7.1.b </strong>The assessor shall examine evidence, including the vendor threat information obtained in Test Requirement 4.1.a, and test the software to confirm that:</p><ul><li>Only documented cryptographic algorithms and modes of operation are used in the software, and</li><li>Protection methods are implemented to mitigate common attacks on cryptographic implementations (for example, the use of the software as a decryption oracle, brute-force or dictionary attacks against the input domain of the sensitive data, the re-use of security parameters such as IVs, or the re-encryption of multiple datasets using linearly applied key values, such as XOR’d key values in stream ciphers or one-time pads).</li></ul></td></tr><tr><td><p><strong>7.1.c </strong>Where cryptographic implementations require a unique value per encryption operation or session, the assessor shall examine evidence and test the software to confirm that the cryptographic implementations do not expose vulnerabilities. For example, this may include the use of a unique IV for a stream cipher mode of operation or a unique and random “k” value for a digital signature.<strong></strong></p></td></tr></tbody></table>

<table><tbody><tr><th><p><strong>Control Objectives</strong></p></th><th colspan="2"><p><strong>Test Requirements</strong></p></th><th></th><th><p><strong>Guidance</strong></p></th></tr><tr><td rowspan="3"><p><strong></strong></p><p><strong></strong></p></td><td colspan="2"><p><strong>7.1.d </strong>Where padding is used prior to or during encryption, the assessor shall examine evidence and test the software to confirm that the encryption operation always incorporates an industry-accepted standard padding method.<strong></strong></p></td><td></td><td rowspan="3"><p></p><p></p></td></tr><tr><td colspan="2"><p><strong>7.1.e</strong> Where hash functions are used to protect sensitive data, the assessor shall examine evidence and test the software to confirm that:</p><ul><li>Only approved, collision-resistant hash algorithms and methods are used for this purpose, and</li><li>A salt value of appropriate strength that is generated using a secure random number generator is used to ensure the resultant hash has sufficient entropy.</li></ul></td><td rowspan="2"></td></tr><tr><td></td><td><p><strong><em>Note:</em></strong><em> The assessor should refer to Control Objective 7.3 for more information on secure random number generators.</em><strong><em></em></strong></p></td></tr><tr><td><p><strong>7.2 </strong>The software supports industrystandard key management processes and procedures. Industrystandard key management processes and procedures are those recognized by industry standards bodies, such as NIST, ANSI, and ISO.<strong></strong></p></td><td colspan="2"><p><strong>7.2.a</strong> The assessor shall examine evidence to confirm that information is maintained that describes the following for each key specified in the inventory:</p><ul><li>Key label or name</li><li>Key location</li><li>Effective date</li><li>Expiration date</li><li>Key purpose/type</li><li>Key generation method/algorithm used</li><li>Key length<strong></strong></li></ul></td><td></td><td><p>Whether implemented within or outside the software, the manner in which cryptographic keys are managed is a critical part of the continued security of payment software and the sensitive data it handles.</p><p>While cryptographic key management processes are often implemented as operational procedures, the software should support secure key-management practices based on industry standards or best practices.</p><p><em>(continued on next page)</em></p></td></tr></tbody></table>

<table><tbody><tr><th><p><strong>Control Objectives</strong></p></th><th><p><strong>Test Requirements</strong></p></th><th><p><strong>Guidance</strong></p></th></tr><tr><td><p><strong></strong></p></td><td><p><strong>7.2.b </strong>The assessor shall examine evidence and test the software to validate the evidence examined in Test Requirement 7.2.a and to confirm that:</p><ul><li>All cryptographic keys that are used for providing security to critical assets (confidentiality, integrity, and authenticity) and other security services to the software have a unique purpose, and that no key is used for both encryption and authentication operations.</li><li>All keys have defined generation methods, and no secret or private cryptographic keys relied upon for security of critical assets are shared between software instances, except when a common secret or private key is used for securing the storage of other cryptographic keys that are generated during the installation, initialization, or first use of the software (for example, white-box cryptography).<strong></strong></li><li>All cryptographic keys have an equivalent bit strength of at least 128 bits in accordance with industry standards.</li><li>All keys have a defined cryptoperiod aligned with industry standards, and methods are implemented to retire and/or update each key at the end of the defined cryptoperiod.</li><li>The integrity and confidentiality of all secret and private cryptographic keys managed by the software are protected when stored (for example, encrypted with a key-encrypting key that is at least as strong as the data-encrypting key and is stored separately from the data-encrypting key, or as at least two full-length key components or key shares, in accordance with an industry-accepted method).</li><li>All keys have a defined generation or injection process, and this process ensures sufficient entropy for the key.</li><li>All key-generation functions must implement one-way functions or other irreversible key-generation processes, and no reversible key calculation modes (such as key variants) are used to directly create new keys from an existing key.<strong></strong></li></ul></td><td><p>Industry-standard key management practices should be applied to the following:</p><ul><li>The generation of strong cryptographic keys.</li><li>Secure cryptographic key distribution.</li><li>Secure cryptographic key storage.</li><li>Cryptographic key changes for keys that have reached the end of their cryptoperiod.</li><li>The retirement or replacement of keys.</li><li>The enforcement of split knowledge and dual control (when the software supports manual clear-text cryptographic key-management operations).</li><li>The prevention of unauthorized substitution of cryptographic keys.</li><li>The implementation of a mechanism to render irretrievable any cryptographic key material or cryptogram stored by the payment software.</li></ul><p>This requirement applies to keys used to encrypt sensitive data and any respective key-encrypting keys.<em></em></p></td></tr></tbody></table>

| **Control Objectives** | **Test Requirements** | **Guidance** |
| --- | --- | --- |
|     | **7.2.c** Where cryptography is used to protect a key, the assessor shall examine evidence and test the software to confirm that security is not provided to any key by a key of lesser strength (for example, by encrypting a 256-bit AES key with a 128-bit AES key). |     |
| **7.2.d** Where public keys are used by the system, the assessor shall examine evidence and test the software to confirm that the authenticity of all public keys is preserved. |
| **7.2.e** Where public or white-box keys are not unique per software instantiation the assessor shall examine evidence to confirm that methods and procedures to revoke and/or replace such keys (or key pairs) exist. |
| **7.2.f** Where the software relies upon external files or other data elements for key material, such as for public TLS certificates, the assessor shall examine evidence to confirm that guidance on how to install such key material, including details noting any security requirements for such key material is provided to stakeholders in accordance with Control Objective 12.1. |
| **7.2.g** Where public keys are manually loaded or used as root keys, the assessor shall examine evidence and test the software to confirm that the keys are installed and stored in a way that provides dual control (to a level that is feasible for the execution environment), preventing a single user from replacing a key to enable a man-in-the-middle attack or the allow for unauthorized decryption of stored data. Where complete dual control is not feasible (for example, due to a limitation of the execution environment), the assessor shall confirm that the methods implemented are appropriate to protect the public keys. |

<table><tbody><tr><th><p><strong>Control Objectives</strong></p></th><th><p><strong>Test Requirements</strong></p></th><th><p><strong>Guidance</strong></p></th></tr><tr><td><p><strong></strong></p></td><td><p><strong>7.2.h</strong> The assessor shall examine evidence to confirm that secret and/or private keys are managed in a way that ensures split knowledge over the key to a level that is feasible given the platform on which the software is executed. Where absolute split knowledge is not feasible, the assessor shall confirm that the methods implemented are reasonable to protect secrets and/or private keys.<strong></strong></p></td><td><p></p></td></tr><tr><td rowspan="3"><p><strong>7.3 </strong>All random numbers used by the software are generated using only industry-standard random number generation (RNG) algorithms or libraries. Industry-standard RNG algorithms or libraries are those that meet industry standards for sufficient unpredictability (for example, <em>NIST Special Publication 800-22</em>).<strong></strong></p><p><strong></strong></p><p><strong></strong></p></td><td><p><strong>7.3.a </strong>The assessor shall examine evidence and test the software to identify all random number generators used by the software and to confirm that all random number generation methods:</p><ul><li>Use at least 128 bits of entropy prior to the output of any random numbers.</li><li>Ensure it is not possible for the system to provide or produce reduced entropy upon start-up or entry of other predictable states of the system.<strong></strong></li></ul></td><td rowspan="3"><p>Random numbers are often used with cryptography to protect sensitive information. Encryption keys and initialization values (seeds) are examples of implementations in which random numbers are required.</p><p>It is not a trivial endeavor to design and implement a secure random number generator. Software vendors are required to use only approved random number generation algorithms and libraries or provide evidence to illustrate how the random number generation algorithms and libraries were tested to confirm that random numbers generated are sufficiently unpredictable.</p><p>The implementation may rely on either a validated cryptographic library or module. The software vendor should have a good understanding of the installation, initialization, configuration, and usage (for example, initial seeding of the random function) of the RNG mechanisms to ensure that the implementation can meet the effective security strength required for the intended use.</p></td></tr><tr><td><p><strong>7.3.b </strong>Where third-party software, platforms, or libraries are used for all or part of the random number generation process, the assessor shall examine evidence (such as current publicly available literature) to confirm that the third-party software does not expose any vulnerabilities that may compromise its use for generating random values.<strong></strong></p></td></tr><tr><td><p><strong>7.3.c </strong>Where the software vendor relies on a previous assessment of the random number generator or source of initial entropy, the assessor shall examine evidence (such as the approval records of the previous assessment) to confirm that this scheme and specific approval include the correct areas of the software in the scope of its assessment, and that the vendor claims do not exceed the scope of the evaluation or approval of that software. For example, some cryptographic implementations approved under FIPS 140-2 or 140-3 require seeding from an external entropy source to correctly output random data.<strong></strong></p></td></tr></tbody></table>

<table><tbody><tr><th><p><strong>Control Objectives</strong></p></th><th colspan="2"><p><strong>Test Requirements</strong></p></th><th></th><th><p><strong>Guidance</strong></p></th></tr><tr><td rowspan="2"><p><strong></strong></p></td><td colspan="2"><p><strong>7.3.d </strong>Where the software vendor does not rely on a previous assessment of the random number generator or source of initial entropy, the assessor shall test the software to obtain 128MB of data output from each random number generator implemented in the system to confirm the lack of statistical correlation in the output. This data may be generated by the assessor directly, or supplied by the vendor, but the assessor must confirm that the generation method implemented ensures that the data is produced as it would be produced by the software during normal operation.</p></td><td rowspan="2"></td><td rowspan="2"><p></p></td></tr><tr><td></td><td><p><strong><em>Note:</em></strong><em> The assessor can use the NIST Statistical Test Suite to identify statistical correlation in the random number generation implementation.</em><strong><em></em></strong></p></td></tr><tr><td><p><strong>7.4 </strong>Random values have entropy that meets the minimum effective strength requirements of the cryptographic primitives and keys that rely on them.<strong></strong></p></td><td colspan="2"><p><strong>7.4.a</strong> The assessor shall examine evidence and test the software to confirm that the methods used for the generation of all cryptographic keys and other material (such as IVs, “k” values for digital signatures, and so on) have entropy that meets the minimum effective strength requirements of the cryptographic primitives and keys.<strong></strong></p></td><td></td><td><p>Entropy is the degree of randomness of a random value generator. The higher the entropy, the less predictable the next value in a random number generator is likely to be.</p><p><em>(continued on next page)</em></p></td></tr><tr><td><p><strong>Control Objectives</strong></p></td><td colspan="3"><p><strong>Test Requirements</strong></p></td><td><p><strong>Guidance</strong></p></td></tr><tr><td><p><strong></strong></p></td><td colspan="3"><p><strong>7.4.b</strong> Where cryptographic keys are generated through processes which require direct user interaction, such as through the entry of a passphrase or the use of “random” user interaction with the software, the assessor shall examine evidence and test the software to confirm that these processes are implemented in such a way that they provide sufficient entropy. Specifically, the assessor shall confirm that:</p><ul><li>Methods used for generating keys directly from a password/passphrase enforce an input domain that is able to provide sufficient entropy, such that the total possible inputs are at least equal to that of the equivalent bit strength of the key being generated (for example, a 32hex-digit input field for an AES128 key).</li><li>Passphrases are passed through an industry-standard keyderivation function, such as PBKDF2 or bcrypt, which extends the work factor for any attempt to brute-force a passphrase value. The assessor shall confirm that a work factor of at least 10,000 is applied to any such implementation.</li><li>Guidance is provided to stakeholders in accordance with Control Objective 12.1 that includes instructions that any passphrase used must:<ul><li>Be randomly generated itself using a valid and secure random process, and that an online random number generator must not be used for this purpose.</li><li>Not be implemented by a single person, such that one person has an advantage in recovering the clear key value, violating the requirements for split knowledge.<strong></strong></li></ul></li></ul></td><td><p>Note that a non-deterministic random number generator (NDRG) may produce an output string that contains less entropy than implied by the length of the output. A deterministic random number generator</p><p>(DRNG) is dependent on the entropy of its seed value.</p></td></tr></tbody></table>

### Secure Software Operations

**_The software provides mechanisms to detect and alert on anomalous activity and to ensure user accountability._**

<table><tbody><tr><th><p><strong>Control Objectives</strong></p></th><th><p><strong>Test Requirements</strong></p></th><th><p><strong>Guidance</strong></p></th></tr><tr><td colspan="2"><p><strong>Control Objective 8: Activity Tracking</strong></p><p>All software activities involving critical assets are tracked.<strong></strong></p></td><td></td></tr><tr><td><p><strong>8.1 </strong>All access attempts and usage of critical assets are tracked and traceable to a unique user.</p><table><tbody><tr><th><p><strong><em>Note:</em></strong><em> This Secure Software Standard recognizes that some execution environments cannot support the detailed logging requirements in other PCI standards. Therefore, the term “activity tracking” is used here to differentiate the expectations of this standard with regards to logging from similar requirements in other PCI standards.</em></p></th></tr></tbody></table></td><td><p><strong>8.1 </strong>The assessor shall examine evidence and test the software to confirm that all access attempts and usage of critical assets are tracked and traceable to a unique individual, system, or entity.</p></td><td><p>To ensure user accountability and to support postincident forensic investigation, payment software should capture and maintain historical records of all software activities involving critical assets and ensure that all such activities are traceable to a unique user (for example, a person, system, or other entity).</p><p>Examples of activities that the software should record include:</p><ul><li>All individual user attempts to access sensitive data or resources.</li><li>Usage of or changes to sensitive functions, such as the software’s identification and authentication mechanisms or activity tracking mechanisms.</li><li>Initialization, stopping, or pausing of sensitive functions.</li></ul><p>This control objective does not mandate the logging of each encryption operation or function processing sensitive data, but it does require that access is tracked and any methods that may expose sensitive data are also tracked.</p></td></tr></tbody></table>

<table><tbody><tr><th><p><strong>Control Objectives</strong></p></th><th><p><strong>Test Requirements</strong></p></th><th><p><strong>Guidance</strong></p></th></tr><tr><td rowspan="3"><p><strong>8.2 </strong>All activity is captured in sufficient and necessary detail to accurately describe the specific activities that were performed, who performed them, the time they were performed, and the critical assets that were affected.<strong></strong></p></td><td><p><strong>8.2.a </strong>The assessor shall examine evidence and test the software to confirm that the tracking method(s) implemented capture specific activity performed, including:</p><ul><li>Enablement of any privileged modes of operation.</li><li>Disabling of encryption of sensitive data.</li><li>Decryption of sensitive data.</li><li>Exporting of sensitive data to other systems or processes.</li><li>Failed authentication attempts.</li><li>Disabling or deleting a security control or altering security functions.<strong></strong></li></ul></td><td rowspan="3"><p>By recording the details in this requirement for all attempts to access or use critical assets, malicious activity or potential software or data compromise can be quickly identified and with sufficient detail to know who performed the activity, whether the attempt was successful, when the activity occurred, what critical assets were affected, and the origination of the event.</p></td></tr><tr><td><p><strong>8.2.b </strong>The assessor shall examine evidence and test the software to confirm that the tracking method(s) implemented provide the following:</p><ul><li>A unique identification for the individual, system, or entity accessing or using critical assets.</li><li>A timestamp for each tracked event.</li><li>Details on what critical asset has been accessed.<strong></strong></li></ul></td></tr><tr><td><p><strong>8.2.c </strong>The assessor shall test the software to confirm that confidential data is not directly recorded in the tracking data.<strong></strong></p></td></tr><tr><td><p><strong>8.3 </strong>The software supports secure retention of detailed activity records.<strong></strong></p></td><td><p><strong>8.3.a </strong>Where the activity records are managed by the software, including only temporarily before being passed to other systems, the assessor shall examine evidence and test the software to confirm that the protection methods are implemented to protect completeness, accuracy, and integrity of the activity records.<strong></strong></p></td><td><p>In order to identify anomalous behavior and to enable forensic investigation upon suspicion of potential software or data compromise, the software must provide for the retention of detailed activity records either through native means (within the software itself) or support integration with other solutions such as centralized log servers, cloud-based logging solutions, or back-end monitoring solutions.</p><p><em>(continued on next page)</em></p></td></tr></tbody></table>

<table><tbody><tr><th><p><strong>Control Objectives</strong></p></th><th><p><strong>Test Requirements</strong></p></th><th><p><strong>Guidance</strong></p></th></tr><tr><td rowspan="2"><p><strong></strong></p></td><td><p><strong>8.3.b </strong>Where the software utilizes external or third-party systems for the maintenance of tracking data, such as a log server, the assessor shall examine evidence to confirm that guidance on the correct and complete setup and/or integration of the software with the external or third-party system(s) is provided to stakeholders in accordance with Control Objective 12.1.<strong></strong></p></td><td rowspan="2"><p>Without adequate protection of activity records, their completeness, accuracy, and integrity cannot be guaranteed and any reliance that would otherwise be placed on them (such as during a forensic investigation) would be negated.</p><p>When activity records are managed by the software, the records must be protected in accordance with all applicable requirements for the protection of sensitive data.</p></td></tr><tr><td><p><strong>8.3.c</strong> The assessor shall test the software to confirm methods are implemented to secure the authenticity of the tracking data during transmission to the log storage system, and to confirm that this protection meets the requirements of this standard (for example, authenticity parameters must be applied using strong cryptography) and any account or authentication parameters used for access to an external logging system are protected.<strong></strong></p></td></tr><tr><td><p><strong>8.4 </strong>The software handles failures in activity-tracking mechanisms such that the integrity of existing activity records is preserved.<strong></strong></p></td><td><p><strong>8.4.a </strong>The assessor shall examine evidence and test the software to confirm that the failure of the activity-tracking mechanism(s) does not violate the integrity of existing records by confirming that:</p><ul><li>The software does not overwrite existing tracking data upon a restart of the software. Each new start shall only append to existing datasets or shall create a new tracking dataset.</li><li>Where unique dataset names are relied upon for maintaining integrity between execution instances, the implementation ensures that other software (including another instance of the same software) cannot overwrite or render invalid existing datasets.</li></ul><p><em>(continued on next page)</em></p></td><td><p>Software security controls should be implemented to ensure that when activity-tracking mechanism(s) fail, those failures are handled in a way that maintains the integrity of the records. Otherwise, attackers may intentionally target activity-tracking mechanisms and cause failures that would allow the attackers to conceal or overwrite evidence of their activities.</p></td></tr></tbody></table>

<table><tbody><tr><th><p><strong>Control Objectives</strong></p></th><th><p><strong>Test Requirements</strong></p></th><th><p><strong>Guidance</strong></p></th></tr><tr><td rowspan="2"><p><strong></strong></p></td><td><p><strong>8.4.a</strong></p><p>• The software applies, where possible, suitable file privileges to assist with maintaining the integrity of the tracking dataset (such as applying an append-only access control to a dataset once created). Where the software does not apply such controls, the assessor shall confirm reasonable justification exists describing why this is the case, why the behavior is sufficient, and what additional mitigations are applied to maintain the integrity of the tracking data.</p></td><td rowspan="2"><p></p></td></tr><tr><td><p><strong>8.4.b </strong>The assessor shall examine evidence and test the software to confirm that the integrity of activity tracking records is maintained by:</p><ul><li>Performing actions that should be tracked, force-closing and then restarting the software, and performing other tracked actions.</li><li>Performing actions that should be tracked, power-cycling the platform on which the software is executing, and then restarting the software and performing other tracked actions.</li><li>Locking access to the tracking dataset and confirming that the software handles the inability to access this dataset in a secure way, such as by creating a new dataset or preventing further use of the software.</li><li>Preventing the creation of new dataset entries by preventing further writing to the media on which the dataset is located (for example, by using media that has insufficient available space).</li></ul><p>Where any of the tests above are not possible, the assessor shall interview personnel to confirm reasonable justification exists to describe why this is the case and shall confirm protections are in place to prevent such scenarios from affecting the integrity of the tracking records.<strong></strong></p></td></tr></tbody></table>

| **Control Objectives** | **Test Requirements** | **Guidance** |
| --- | --- | --- |
| **Control Objective 9: Attack Detection**<br><br>Attacks are detected, and the impacts/effects of attacks are minimized. |     |     |
| **9.1** The software detects and alerts upon detection of anomalous behavior, such as changes in postdeployment configurations or obvious attack behavior. | **9.1.a** The assessor shall examine evidence and test the software to confirm that methods are implemented to validate the integrity of software executables and any configuration options, files, and datasets that the software relies upon for operation such that unauthorized post-deployment changes are detected.<br><br>Where the execution environment prevents this, the assessor shall examine evidence (including publicly available literature on the platform and associated technologies) to confirm that there are indeed no methods for validating authenticity, and that additional security controls are implemented to minimize the associated risk. | Software should possess basic functionality to differentiate between normal and anomalous user behavior. Examples of anomalous behavior that should be automatically detected by the software include changes in post-deployment (or post-initialization) configurations or obvious automated-attack behaviors, such as repeated authentication attempts at a frequency that is infeasible for a human user.<br><br>In some cases, it may be impractical to implement these capabilities directly into payment software, and third-party tools or services may be required. Where such tools or services are relied upon, the software vendor must provide guidance (or direction on where appropriate guidance may be obtained) that describes how and to what extent third-party tools and services should be configured to satisfy the control objective and associated test requirements. |
| **9.1.b** The assessor shall examine evidence and test the software to confirm that integrity values used by the software and dataset(s) upon which it relies for secure operation are checked upon software execution, and at least every 36 hours thereafter (if the software continues execution during that time period). |
| **9.1.c** Where cryptographic primitives are used by any anomalydetection methods, the assessor shall examine evidence and test the software to confirm that the cryptographic primitives are protected. |
| **9.1.d** Where stored values are used by any anomaly detection methods, the assessor shall examine evidence and test the software to confirm that these values are considered sensitive data and are protected accordingly. |
| **9.1.e** Where configuration or other dataset values can be modified by the software during execution, the assessor shall examine evidence and test the software to confirm that integrity protections are implemented to allow for this update while still ensuring dataset integrity can be validated after the update. |
| **Control Objectives** | **Test Requirements** | **Guidance** |
|     | **9.1.f** The assessor shall examine evidence and test the software to confirm that the software implements controls to prevent brute-force attacks on account, password, or cryptographic-key input fields (for example, input rate limiting). |     |
| **9.1.g** Where third-party tools or services are relied upon by the software to provide attack detection capabilities, the assessor shall examine evidence to confirm that guidance on how to configure such tools and services to support this control objective is provided to stakeholders in accordance with Control Objective 12.1. |

### Secure Software Lifecycle Management

**_The software is maintained using secure software lifecycle management practices._**

<table><tbody><tr><th><p><strong>Control Objectives</strong></p></th><th><p><strong>Test Requirements</strong></p></th><th><p><strong>Guidance</strong></p></th></tr><tr><td colspan="2"><p><strong>Control Objective 10: Threat and Vulnerability Management</strong></p><p>Payment software threats and vulnerabilities are identified, assessed, and managed appropriately.<strong></strong></p></td><td></td></tr><tr><td rowspan="3"><p><strong>10.1</strong> Software threats and vulnerabilities are identified, assessed, and addressed.<strong></strong></p></td><td><p><strong>10.1.a</strong> Using information obtained in Test Requirement 4.1.a, the assessor shall examine evidence to confirm that common attack methods against the software are identified. This may include platform-level, protocol-level, and/or language-level attacks.</p></td><td rowspan="3"><p>Determining how to effectively secure and defend the software against attacks requires a thorough understanding of the specific threats and potential vulnerabilities applicable to the vendor’s software. This typically involves understanding the following:</p><ul><li>The types of information collected, stored, processed, or transmitted by the software.</li><li>The motivations an attacker may have for attacking the software.</li><li>The methods an attacker might utilize or the vulnerabilities an attacker might try to exploit during an attack.</li><li>The exploitability of any identified vulnerabilities.</li><li>The impact a successful attack.</li></ul><p>The identified threats and vulnerabilities should be tracked, assigned to responsible personnel, and fixed or mitigated prior to payment software release.</p><p>For guidance on threat analysis and cyber-resiliency design principles, refer to industry standards and guidance, such as the current version of <em>NIST Special Publication 800-160</em>.</p></td></tr><tr><td><p><strong>10.1.b</strong> The assessor shall examine evidence to confirm that the identified attacks are valid for the software and shall note where this does not include common attack methods detailed in industry-standard references such as OWASP and CWE lists.</p></td></tr><tr><td><p><strong>10.1.c</strong> The assessor shall examine evidence to confirm that mitigations against each identified attack are implemented, and that the software release process includes ongoing validation of the existence of these mitigations.</p></td></tr></tbody></table>

<table><tbody><tr><th><p><strong>Control Objectives</strong></p></th><th><p><strong>Test Requirements</strong></p></th><th><p><strong>Guidance</strong></p></th></tr><tr><td rowspan="3"><p><strong>10.2</strong> Vulnerabilities in the software and third-party components are tested for and fixed prior to release.</p></td><td><p><strong>10.2.a </strong>The assessor shall examine evidence to confirm that robust testing processes are used throughout the software lifecycle to manage vulnerabilities in software and to verify that the mitigations used to secure the software against attacks remain in place and are effective.<strong></strong></p></td><td rowspan="3"><p>Most software vulnerabilities are introduced as a result of coding errors, bad design, improper implementation, or the use of vulnerable components.</p><p>Software should be developed and tested in a manner that minimizes the existence of any vulnerabilities and detects those that emerge over time, such that the vulnerabilities may be addressed before the software is released or updated.</p><p>Techniques to avoid the introduction of vulnerabilities during development include the use of security coding practices, testing code during each phase of the development lifecycle using automated tools (such as static/dynamic analysis tools and interactive security testing tools), and the use of known secure components (for example, common code that has already undergone significant security vetting). To minimize the introduction of software vulnerabilities from third-party components, those components must also be evaluated. Ideally, they should be subject to the same secure development and testing processes as the software created by the vendor.</p><p>Security testing should be performed by appropriately skilled vendor personnel or third parties. In addition, security testing personnel should be able to conduct tests in an objective manner and be authorized to escalate any identified vulnerabilities to appropriate management or development personnel, so they can be properly addressed.</p></td></tr><tr><td><p><strong>10.2.b </strong>The assessor shall examine evidence including documented testing processes and output of several instances of the testing to confirm that the testing process:</p><ul><li>Includes, at a minimum, the use of automated tools capable of detecting vulnerabilities both in software code and during software execution.</li><li>Includes the use of security testing tools that are suitable for the software architecture, development languages, and frameworks used in the development of the software.</li><li>Accounts for the entire code base and detects vulnerabilities in third-party, open-source, or shared components and libraries.<strong></strong></li><li>Accounts for common vulnerabilities and attack methods.<strong></strong></li><li>Demonstrates a history of finding software vulnerabilities and remediating them prior to software release.<strong></strong></li></ul></td></tr><tr><td><p><strong>10.2.c </strong>Where evidence examined in Test Requirement 10.2.b shows the release of software with known vulnerabilities, the assessor shall examine further evidence to confirm that:</p><ul><li>An industry-standard vulnerability-ranking system (such as CVSS) is used to classify/categorize vulnerabilities.</li><li>A remediation plan is maintained for all detected vulnerabilities that ensures vulnerabilities do not remain unmitigated for an indefinite period.<strong></strong></li></ul></td></tr></tbody></table>

<table><tbody><tr><th><p><strong>Control Objectives</strong></p></th><th><p><strong>Test Requirements</strong></p></th><th><p><strong>Guidance</strong></p></th></tr><tr><td colspan="3"><p><strong>Control Objective 11: Secure Software Updates</strong></p><p>Software releases and updates to address vulnerabilities are provided in a secure and timely manner.<strong></strong></p></td></tr><tr><td rowspan="2"><p><strong>11.1</strong> Software updates to fix known vulnerabilities are made available to stakeholders in a timely manner.<strong></strong></p></td><td><p><strong>11.1.a</strong> The assessor shall examine evidence to confirm that:</p><ul><li>Reasonable criteria are defined for releasing software updates to fix security vulnerabilities.</li><li>Security updates are made available to stakeholders in accordance with the defined criteria.<strong></strong></li></ul></td><td rowspan="2"><p>Vulnerabilities in software should be fixed as soon as possible to enable software users and other stakeholders to address any risks before vulnerabilities in their payment systems and software can be exploited by attackers.</p><p>Vulnerabilities should be addressed in a manner that is commensurate with the risk they pose to software users or other stakeholders. The most critical or severe vulnerabilities (those with the highest exploitability and the greatest potential impact to stakeholders) should be patched immediately, followed by those with moderate-to-low exploitability or potential impact. The criteria for determining how and when to make patches available to stakeholders should be defined and followed.</p></td></tr><tr><td><p><strong>11.1.b</strong> The assessor shall examine evidence, including updatespecific security-testing results and details, to confirm that security updates are made available to stakeholders in accordance with the defined criteria. Where updates are not provided in accordance with the defined criteria, the assessor shall confirm that such instances are justified and reasonable.<strong></strong></p></td></tr><tr><td rowspan="3"><p><strong>11.2</strong> Software releases and updates are delivered in a secure manner that ensures the integrity of the software code.</p></td><td><p><strong>11.2.a </strong>The assessor shall examine evidence to confirm that the method(s) by which the vendor releases software updates maintain the integrity of the software code during transmission and installation.</p></td><td rowspan="3"><p>Security updates should include a mechanism within the update process to verify the update code has not been replaced or tampered with. Examples of integrity checks include, but are not limited to, checksums and digitally signed certificates (where implemented correctly). Verification could be implemented within the software itself or through guidance that is provided to stakeholders to direct them on the manual verification of software updates.</p><p>In addition, the process of distributing updates and patches should prevent malicious individuals from intercepting the updates in transit, modifying them, and then redistributing them to unsuspecting stakeholders.</p></td></tr><tr><td><p><strong>11.2.b</strong> Where user input or interaction is required to validate the integrity of the software code, the assessor shall examine evidence to confirm that guidance on this process is provided to stakeholders in accordance with Control Objective 12.1.</p></td></tr><tr><td><p><strong>11.2.c </strong>Where the integrity method implemented is not cryptographically secure, the assessor shall examine evidence to confirm that the software distribution method provides a chain of trust, such as through use of a TLS connection that provides compliant cipher-suite implementations.</p></td></tr></tbody></table>

| **Control Objectives** | **Test Requirements** | **Guidance** |
| --- | --- | --- |
|     | **11.2.d** The assessor shall examine vendor evidence to confirm that stakeholders are notified of software updates, and that guidance on how they may be obtained and installed is provided to stakeholders in accordance with Control Objective 12.1. |     |
| **11.2.e** The assessor shall examine evidence to confirm that stakeholders are notified when known vulnerabilities are detected in software that has not yet been updated with a fix. This includes vulnerabilities that may exist in third-party software and libraries used by the software. The assessor shall confirm that this process includes providing the stakeholders with suggested mitigations for any such vulnerabilities. |
| **11.2.f** The assessor shall examine evidence to confirm that the software update mechanisms cover all software, configuration files, and other metadata that may be used by the software for security purposes or which may in some way affect the security of the software. |

<table><tbody><tr><th><p><strong>Control Objectives</strong></p></th><th><p><strong>Test Requirements</strong></p></th><th><p><strong>Guidance</strong></p></th></tr><tr><td colspan="3"><p><strong>Control Objective 12: Software Vendor Implementation Guidance</strong></p><p>The software vendor provides stakeholders with clear and thorough guidance on the secure implementation, configuration, and operation of the software.<strong></strong></p></td></tr><tr><td rowspan="2"><p><strong>12.1 </strong>The software vendor provides stakeholders with clear and thorough guidance on the secure implementation, configuration, and operation of its payment software.</p></td><td><p><strong>12.1.a</strong> The assessor shall examine evidence to confirm that the vendor creates and provides stakeholders, clear and sufficient guidance to allow for the secure installation, configuration, and use of the software.</p></td><td rowspan="2"><p>When followed, the software vendor's implementation guidance provides assurance that the software and patches can be securely installed, configured, and maintained in a customer environment, and that all desired security functions are active and working as intended. The guidance should cover all options and functions available to software users that could affect the security of the software or the data it interacts with. The guidance should also include secure configuration options for any components provided with or supported by the software, such as external software and underlying platforms.</p><p>Examples of configurable options include:</p><ul><li>Changing default credentials and passwords.</li><li>Enabling and disabling software accounts, services, and features.</li><li>Changes in resource access permissions.</li><li>Integration with third-party cryptographic libraries, random number generators, and so on.</li></ul><p>The provided guidance should result in a secure configuration across all supported platforms and all configurable options.</p></td></tr><tr><td><p><strong>12.1.b</strong> The assessor shall examine evidence to confirm that the guidance:</p><ul><li>Includes details on how to securely and correctly install any third-party software that is required for the operation of the vendor software.</li><li>Provides instructions on the correct configuration of the platform(s) on which the software is to be executed, including setting security parameters and installation of any data elements (such as certificates).</li><li>Includes instructions for key management (for example, the use of keys and how they are distributed, loaded, removed, changed, and destroyed.)</li><li>Does not instruct the user to disable security settings or parameters within the installed environment, such as antimalware software or firewall or other network-level protection systems.</li><li>Does not instruct the user to execute the software in a privileged mode higher than what is required by the software.</li><li>Provides details on how to validate the version of the software and clearly indicates for which version(s) of the software the guidance is written.<strong></strong></li></ul><p><em>(continued on next page)</em></p></td></tr></tbody></table>

| **Control Objectives** | **Test Requirements** | **Guidance** |
| --- | --- | --- |
|     | **12.1.b**<br><br>• Provides justification for any requirements in this standard that are to be assessed as not applicable. For each of these, the assessor shall confirm justification exists for why this is the case and shall confirm that it agrees with their understanding and the results of their software testing. |     |

## Module A – Account Data Protection Requirements

| **Module Name** | **Overview** | **Control Objectives** |
| --- | --- | --- |
| **Module A – Account Data Protection Requirements** | Security requirements for software that stores, processes, or transmits account data. | **A.1**: Sensitive Authentication Data<br><br>**A.2**: Cardholder Data Protection |

### Purpose and Scope

This section (hereinafter referred to as the “Account Data Protection Module”) defines security requirements and assessment procedures for software that stores, processes, or transmits Account Data. For the purposes of this module, account data is defined as follows:

<table><tbody><tr><th></th><th colspan="2"><p><strong>Account Data</strong></p></th></tr><tr><td></td><td><p><strong>Cardholder Data includes:</strong></p></td><td><p><strong>Sensitive Authentication Data includes:</strong></p></td></tr><tr><td><p>▪</p><p>▪</p><p>▪</p><p>▪</p></td><td><p>Primary Account Number (PAN)</p><p>Cardholder Name</p><p>Expiration Date</p><p>Service Code</p></td><td><ul><li>Full track data (magnetic-stripe data or equivalent on a chip)</li><li>CAV2/CVC2/CVV2/CID</li><li>PINs/PIN blocks</li></ul></td></tr></tbody></table>

**_The primary account number (PAN) is the defining factor for cardholder data_.** If PAN is stored, processed, or transmitted or is otherwise present, the requirements in this module apply in addition to the Secure Software Core Requirements.

The table on the following page illustrates commonly used elements of cardholder data and sensitive authentication data, whether storage of that data is permitted or prohibited, and whether this data needs to be protected. This table is not meant to be exhaustive, but it is presented to illustrate the different types of requirements that apply to each data element.

|     |     | **Data Element** | **Storage Permitted** | **Render Stored Data Unreadable per Control Objective A.2.3** |
| --- | --- | --- | --- | --- |
| **Account Data** | **Cardholder Data** | Primary Account Number (PAN) | Yes | Yes |
| Cardholder Name | Yes | No  |
| Service Code | Yes | No  |
| Expiration Date | Yes | No  |
| **Sensitive**<br><br>**Authentication Data**<sup><sup>[\[2\]](#footnote-2)</sup></sup> | Full Track Data <sup><sup>[\[3\]](#footnote-3)</sup></sup> | No  | Cannot store per Control Objective A.1.1 |
| CAV2/CVC2/CVV2/CID<sup><sup>[\[4\]](#footnote-4)</sup></sup> | No  | Cannot store per Control Objective A.1.1 |
| PIN/PIN Block<sup><sup>[\[5\]](#footnote-5)</sup></sup> | No  | Cannot store per Control Objective A.1.1 |

Control Objectives A.2.2 and A.2.3 apply only to PAN. If PAN is stored with other elements of cardholder data, only the PAN must be rendered unreadable according to Control Objective A.2.3. Sensitive authentication data must not be stored after authorization, even if encrypted, unless the software is intended only for use by issuers or organizations that support issuing services. Only in those cases can sensitive authentication data be stored post-authorization.

### Security Requirements

<table><tbody><tr><th><p><strong>Control Objectives</strong></p></th><th><p><strong>Test Requirements</strong></p></th><th><p><strong>Guidance</strong></p></th></tr><tr><td colspan="2"><p><strong>Control Objective A.1: Sensitive Authentication Data</strong></p><p>Sensitive Authentication Data (SAD) is not retained after authorization.<strong></strong></p></td><td></td></tr><tr><td><p><strong>A.1.1 </strong>The software does not store sensitive authentication data after authorization (even if encrypted) unless the software is intended only for use by issuers or organizations that support issuing services.</p><p></p></td><td><p><strong>A.1.1 </strong>Using information obtained in Test Requirement 1.1.a in the Core Requirements section, the assessor shall examine evidence and test the software to identify all potential storage locations for Sensitive Authentication Data, and to confirm that the software does not store such data after transaction authorization is complete. This includes storage of SAD in temporary storage (such as volatile memory), semi-permanent storage (such as RAM disks), and non-volatile storage (such as magnetic and flash storage media).</p><p>Where Sensitive Authentication Data is stored after authorization, the assessor shall examine evidence to confirm that the software is designed explicitly for issuing purposes or for use by issuers or organizations that support issuing services.<strong></strong></p></td><td><p>Sensitive authentication data consists of full track data, card validation code or value, and PIN data. Storage of sensitive authentication data after authorization is prohibited. This data is valuable to malicious individuals as it allows them to generate counterfeit payment cards and create fraudulent transactions.</p><p>Testing should include at least the following types of files, as well as any other output generated by the payment software:</p><ul><li>Incoming transaction data</li><li>All logs (for example, transaction, history, debugging, error)</li><li>History files</li><li>Trace files</li><li>Audio and image files (for example, digital voice and biometrics)</li><li>Non-volatile memory (including non-volatile cache)</li><li>Database schemas</li><li>Database contents</li></ul></td></tr></tbody></table>

<table><tbody><tr><th><p><strong>Control Objectives</strong></p></th><th><p><strong>Test Requirements</strong></p></th><th><p><strong>Guidance</strong></p></th></tr><tr><td colspan="3"><p><strong>Control Objective A.2: Cardholder Data Protection </strong>Stored cardholder data is protected.<strong></strong></p></td></tr><tr><td><p><strong>A.2.1</strong> The software vendor provides guidance to stakeholders regarding secure deletion of cardholder data after expiration of defined retention period(s).</p><p></p></td><td><p><strong>A.2.1</strong> The assessor shall examine evidence to confirm that guidance is provided to stakeholders in accordance with Control Objective 12.1 that details:</p><ul><li>All locations where the software stores cardholder data.</li><li>How to securely delete cardholder data stored by the payment software, including cardholder data stored on underlying software or systems (such as in OS files or in databases).</li><li>How to configure the underlying software or systems to prevent the inadvertent capture or retention of cardholder data (for example, by system backup or restore points).</li></ul></td><td><p>The software vendor must provide details of all locations where the software may store cardholder data, including in any underlying software or systems (such as OS, databases, and so on), as well as instructions for securely deleting the data from these locations once the data has exceeded any defined retention period(s).</p><p>Stakeholders must also be provided with configuration details for the underlying systems that the software runs on to ensure these underlying systems are not capturing cardholder data without the stakeholder’s knowledge.</p><p>Stakeholders need to know how underlying systems could be capturing data from the software so they can either prevent it from being captured or ensure the data is properly protected.</p></td></tr><tr><td rowspan="2"><p><strong>A.2.2</strong> The software provides features to restrict or otherwise mask all displays of PAN to the minimum number of digits required.<strong></strong></p></td><td><p><strong>A.2.2.a</strong> The assessor shall examine evidence to confirm that the software provides features that enable responsible parties to restrict or otherwise mask the display of PAN to the minimum number of digits required to meet a defined business need.</p></td><td rowspan="2"><p>The display of full PAN on items such as computer screens, payment card receipts, logs, faxes, or paper reports can result in this data being obtained by unauthorized individuals and used fraudulently.</p><p>The masking approach should always ensure that only the minimum number of digits is displayed as necessary to perform a specific business function. For example, if only the last four digits are needed to perform a business function, the software should provide features to mask the PAN so that individuals performing that function can view only the last four digits.</p></td></tr><tr><td><p><strong>A.2.2.b</strong> The assessor shall examine evidence to confirm that all displays of PAN are completely masked by default, and that explicit authorization is required to display any digits of the PAN.</p></td></tr></tbody></table>

<table><tbody><tr><th><p><strong>Control Objectives</strong></p></th><th colspan="2"><p><strong>Test Requirements</strong></p></th><th></th><th><p><strong>Guidance</strong></p></th></tr><tr><td rowspan="2"><p></p></td><td colspan="2"><p><strong>A.2.2.c</strong> Where user input or interaction is required to configure PAN masking features and options, the assessor shall examine evidence to confirm that guidance on how to configure these features/options is provided to stakeholders in accordance with Control Objective 12.1.</p></td><td></td><td rowspan="2"><p></p></td></tr><tr><td colspan="2"><p><strong>A.2.2.d</strong> The assessor shall test the software to confirm that all displays of PAN are completely masked by default, and that explicit authorization is required to display any element of the PAN.</p></td><td></td></tr><tr><td rowspan="3"><p><strong>A.2.3 </strong>PAN is rendered unreadable anywhere it is stored (including data on portable digital media, backup media, and in logs) by using any of the following approaches:</p><ul><li>Truncation (hashing cannot be used to replace the truncated segment of PAN).</li><li>Index tokens and pads (pads must be securely stored).</li><li>Strong cryptography with associated key-management processes and procedures.</li></ul><p><strong></strong></p></td><td colspan="2"><p><strong>A.2.3.a </strong>The assessor shall examine evidence and test the software to confirm that methods are implemented to render PAN unreadable anywhere it is stored using the following methods:</p><ul><li>Truncation.</li><li>Index tokens and pads, with the pads being securely stored.</li><li>Strong cryptography, with associated key-management processes and procedures.<strong></strong></li></ul></td><td rowspan="2"></td><td rowspan="3"><p>Lack of protection of PANs can allow malicious individuals to view or download this data. The intent of truncation is that only a portion (not to exceed the first six and last four digits) of the PAN is stored.</p><p>The intent of strong cryptography is that the encryption</p><p>be based on an industry-tested and accepted algorithm (not a proprietary or "home-grown" algorithm) with strong cryptographic keys.</p></td></tr><tr><td></td><td><p><strong><em>Note</em></strong><em>: The assessor should examine several tables, files, log files, and any other resources created or generated by the software to verify the PAN is rendered unreadable.</em></p></td></tr><tr><td colspan="2"><p><strong>A.2.3.b</strong> Where user input or interaction is required to configure methods to render PAN unreadable when stored, the assessor shall examine evidence to confirm that guidance on configuring these options is provided to stakeholders in accordance with Control Objective 12.1 and that the guidance includes the following:</p><p>• Details of any configurable options for each method used to render cardholder data unreadable, and instructions on how to configure each method for all locations where cardholder data is stored.<strong></strong></p><p><em>(continued on next page)</em></p></td><td></td></tr><tr><td><p><strong>Control Objectives</strong></p></td><td colspan="3"><p><strong>Test Requirements</strong></p></td><td><p><strong>Guidance</strong></p></td></tr><tr><td rowspan="4"><p><strong></strong></p></td><td colspan="3"><p><strong>A.2.3.b</strong></p><ul><li>A list of all instances where cardholder data may be output for storage outside of the payment application, and instructions that the implementing entity is responsible for rendering the PAN unreadable in all such instances.</li><li>Instruction that if debugging logs are ever enabled (for troubleshooting purposes) and they contain PAN, they must be protected, that debugging must be disabled as soon as troubleshooting is complete, and that debugging logs must be securely deleted when no longer needed.</li></ul></td><td rowspan="4"><p></p></td></tr><tr><td colspan="3"><p><strong>A.2.3.c </strong>Where software creates both tokenized and truncated versions of the same PAN, the assessor shall examine evidence and test the software to confirm that the tokenized and truncated versions cannot be correlated to reconstruct the original PAN.</p></td></tr><tr><td colspan="3"><p><strong>A.2.3.d </strong>Where software creates or generates files for use outside the software (for example, files generated for export or backup) including for storage on removable media, the assessor shall examine evidence and test the software to confirm that PAN is rendered unreadable.</p></td></tr><tr><td colspan="3"><p><strong>A.2.3.e </strong>If the software vendor stores PAN for any reason (for example, because log files, debugging files, and other data sources are received from customers for debugging or troubleshooting purposes), the assessor shall examine evidence and test the software to confirm that PAN is rendered unreadable in accordance with this control objective.</p></td></tr></tbody></table>

## Module B – Terminal Software Requirements

| **Module Name** | **Overview** | **Control Objectives** |
| --- | --- | --- |
| **Module B: Terminal**<br><br>**Software Requirements** | Security requirements for software intended for deployment and execution on PCI-approved POI devices. | **B.1**: Terminal Software Documentation<br><br>**B.2**: Terminal Software Design<br><br>**B.3**: Terminal Software Attack Mitigation<br><br>**B.4**: Terminal Software Security Testing<br><br>**B.5**: Terminal Software Implementation Guidance |

### Purpose and Scope

This section (hereinafter referred to as the “Terminal Software Module” or “this module”) defines security requirements and assessment procedures for payment software and applications that rely on the security features of PCI-approved POI devices to protect payment data. Software applications that are developed explicitly for deployment and execution on PCI-approved POI devices that do not meet the definition of Firmware as defined in the _PCI PIN Transaction Security (PTS) Point-of-Interaction (POI) Modular Security Requirements_ (hereinafter referred to as the “PCI PTS POI Standard”) are in scope for the requirements in this module.

### Background

PCI-approved POI devices provide a high degree of confidentiality and integrity protection for payment data and payment transactions through the implementation of strict physical and logical protection mechanisms. Software that is deployed and executed on PCI-approved POI devices must not degrade or adversely affect the protection mechanisms provided by the device. In addition, the software must not provide features or functions that could allow those protection mechanisms to be circumvented or rendered ineffective.

The requirements and assessment procedures defined in the Terminal Software Module have been developed to help ensure that terminal software protects payment data and does not introduce features, functions, or weaknesses that could enable an attacker to circumvent or render ineffective the protection mechanisms provided by the underlying PCI-approved POI devices upon which the software is intended to be deployed.

### Considerations

Some assessment procedures in this module require examination of documentation describing the security features and functions of the underlying payment terminal. The terminal software vendor should work with their assessor(s), as well as the respective payment terminal vendors for each of the devices to be included as part of the terminal software evaluation, to identify and compile all device documentation needed for the terminal software evaluation. For more information about Secure Software assessment preparation and activities, refer to the _Secure Software_

_Program Guide_.

### Security Requirements

<table><tbody><tr><th><p><strong>Control Objectives</strong></p></th><th><p><strong>Test Requirements</strong></p></th><th><p><strong>Guidance</strong></p></th></tr><tr><td colspan="3"><p><strong>Control Objective B.1: Terminal Software Documentation</strong></p><p>The software architecture is documented and includes diagrams that describe all software components and services in use and how they interact.</p></td></tr><tr><td><p><strong>B.1.1</strong> The software vendor maintains documentation that describes all software components, interfaces, and services provided or used by the software.</p></td><td><p><strong>B.1.1</strong> The assessor shall examine evidence to confirm that documentation is maintained that describes the software’s overall design and function including, but not limited to, the following:</p><ul><li>All third-party and open-source components, external services, and Application Programming Interfaces (APIs) used by the software.</li><li>All User Interfaces (UI) and APIs provided or made accessible by the software.</li></ul></td><td><p>Software vendors should also maintain detailed documentation that clearly and effectively describes the overall design and function of its software, including all services (internal and external), components, and functions used and provided by the software, and how those services, components, and functions interact.</p></td></tr><tr><td><p><strong>B.1.2</strong> The software vendor maintains documentation that describes all data flows and functions that involve sensitive data.</p><table><tbody><tr><th><p><strong><em>Note: </em></strong><em>This control objective is an extension of Control Objectives 1.1 and 1.2. Validation of these control objectives should be performed at the same time.</em><strong><em></em></strong></p></th></tr></tbody></table></td><td><p><strong>B.1.2.a</strong> The assessor shall examine evidence to confirm that documentation is maintained that describes all sensitive data flows including, but not limited to, the following:</p><ul><li>All sensitive data stored, processed, or transmitted by the software.</li><li>All locations where sensitive data is stored, including both temporary and persistent storage locations.</li><li>How sensitive data is securely deleted from storage (both temporary and persistent) when no longer needed.</li></ul></td><td><p>In addition to identifying the components, interfaces, and services exposed by the software, the software vendor should also maintain documentation that clearly identifies and describes the types of data stored, processed, and transmitted by the software; whether and how that data is shared between components and functions; and the protection mechanisms implemented or relied upon by the software to protect that data. This type of documentation clarifies how data is stored, processed, or transmitted by the software, with whom the data is shared, and how the software may be attacked to gain access to the software’s critical assets.</p></td></tr><tr><td><p><strong>Control Objectives</strong></p></td><td><p><strong>Test Requirements</strong></p></td><td><p><strong>Guidance</strong></p></td></tr><tr><td><p><strong></strong></p></td><td><p><strong>B.1.2.b</strong> The assessor shall examine evidence to confirm that documentation is maintained that describes all functions that handle sensitive data including, but not limited to, the following:</p><ul><li>All inputs, outputs, and possible error conditions for each function that handles sensitive data.</li><li>All cryptographic algorithms, modes of operation, and associated key management practices for all functions that employ cryptography for the protection of sensitive data.</li></ul></td><td><p></p></td></tr><tr><td><p><strong>B.1.3</strong> The software vendor maintains documentation that describes all configurable options that can affect the security of sensitive data.<strong></strong></p></td><td><p><strong>B.1.3</strong> The assessor shall examine evidence to confirm that documentation is maintained that describes all configurable options provided or made available by the software that can impact the security of sensitive data including, but not limited to, the following:</p><ul><li>All configurable options that could allow access to sensitive data.</li><li>All configurable options that could enable modification of any mechanisms used to protect sensitive data.</li><li>All remote access features, functions, and parameters provided or made available by the software.</li><li>All remote update features, functions, and parameters provided or made available by the software.</li><li>The default settings for each configurable option.</li></ul></td><td><p>Software vendors should identify all configurable options available within their software, particularly those that control security features and functions. Configurable features must be considered as potential avenues for attacking the software. Where configurable options enable control over security features and functions, robust security controls should be implemented to protect the configurable security features from being misused. Additionally, all configurable options should be configured to their most secure settings by default in accordance with Control Objective 2.</p></td></tr></tbody></table>

<table><tbody><tr><th colspan="3"><p><strong>Control Objectives</strong></p></th><th><p><strong>Test Requirements</strong></p></th><th><p><strong>Guidance</strong></p></th></tr><tr><td colspan="5"><p><strong>Control Objective B.2: Terminal Software Design</strong></p><p>The software does not implement any feature that enables the security features, functions, and characteristics of the payment terminal to be circumvented or rendered ineffective.</p></td></tr><tr><td colspan="3"><p><strong>B.2.1</strong> The software is intended for deployment and operation on payment terminals (PCI-approved POI devices).</p></td><td><p><strong>B.2.1</strong> The assessor shall examine evidence to determine the payment terminals upon which the software is to be deployed. For each of the payment terminals identified and included in the software assessment, the assessor shall examine the payment terminal’s device characteristics and compare them with the following characteristics specified in the <em>PCI SSC’s List of Approved PTS Devices</em> to confirm they match:</p><ul><li>Model name/number</li><li>PTS approval number</li><li>Hardware version number</li><li>Firmware version number(s)</li></ul></td><td><p>Payment terminals provide a high degree of confidentiality and integrity protection for payment data and payment transactions through the implementation of strict physical and logical protection mechanisms. Software that is deployed and executed on these payment terminals should use the approved features and functions provided by the payment terminal rather than implementing its own equivalent features or functions, to avoid exposing vulnerabilities or other weaknesses that could allow an attacker to circumvent or render ineffective the security features of the payment terminal.</p></td></tr><tr><td colspan="3" rowspan="2"><p><strong>B.2.2</strong> The software uses only the external communication methods included in the payment terminal’s PTS device evaluation.</p></td><td><p><strong>B.2.2.a</strong> The assessor shall examine evidence (including source code) to determine whether the software supports external communications.<strong></strong></p></td><td rowspan="4"><p>To ensure software does not degrade or defeat the security mechanisms provided by the underlying payment terminal, the software must use the deviceprovided security features and functions in accordance with the payment terminal vendor’s</p><p>security guidance/policy. This is particularly true for external communication methods. Under no circumstances should the software provide its own communication methods (for example, VMs, IP stack, scripting languages, and so on) to control device-level interfaces. The introduction of any such function by the software could introduce new vulnerabilities or weaknesses that would allow malicious entities to circumvent the security protections provided by the payment terminal and degrade the overall security characteristics of both the software and the underlying device.</p></td></tr><tr><td rowspan="2"><p><strong>B.2.2.b</strong> Where the software supports external communications, the assessor shall examine all relevant payment terminal documentation (including the payment terminal vendor’s security guidance/policy) to determine which external communication methods were included in the payment terminal’s PTS device evaluation.<strong></strong></p></td></tr><tr><td rowspan="2"></td><td rowspan="2"><p><strong><em>Note: </em></strong><em>The payment terminal may provide an IP stack approved per the PTS Open Protocols module, or the</em></p><p><em>device may provide serial ports or modems approved by the PTS evaluation to communicate</em></p><p><em>transaction data encrypted by its PCI PTS SRED functions. Using any external communication methods not included in the PCI-approved POI device evaluation invalidates the PTS approval, and such use is prohibited for terminal software.</em><strong><em></em></strong></p></td><td rowspan="2"></td></tr><tr><td><p><strong>B.2.2.c</strong> The assessor shall examine evidence (including source code) to confirm that the software uses only the external communication methods included in the payment terminal’s PTS device evaluation and does not implement its own external communication methods or IP stack.<strong></strong></p></td></tr></tbody></table>

<table><tbody><tr><th><p><strong>Control Objectives</strong></p></th><th><p><strong>Test Requirements</strong></p></th><th><p><strong>Guidance</strong></p></th></tr><tr><td><p><strong>B.2.2.1</strong> Where the software relies on the Open Protocols feature of the payment terminal, the software is developed in accordance with the payment terminal vendor’s security guidance/policy.<strong></strong></p></td><td><p><strong>B.2.2.1</strong> The assessor shall examine all relevant payment terminal documentation (including the payment terminal vendor’s security guidance/policy) and all relevant software vendor process documentation and software design documentation to confirm that the software is developed in accordance with the payment terminal vendor’s security guidance/policy.<strong></strong></p></td><td><p>Payment terminal vendor security guidance/policy is intended for application developers, system integrators, and end-users of the platform to meet the PCI PTS POI Open Protocol (as well as other PTS) requirements as part of a PCI-approved POI device evaluation.</p></td></tr><tr><td><p><strong>B.2.2.2</strong> The software does not circumvent, bypass, or add additional services or protocols to the Open Protocols of the payment terminal as approved and documented in the payment terminal vendor’s security guidance/policy. This includes the use of:</p><ul><li>Link Layer protocols</li><li>IP protocols</li><li>Security protocols</li><li>IP Services</li></ul></td><td><p><strong>B.2.2.2</strong> The assessor shall examine evidence (including source code) to confirm that the software does not circumvent, bypass, or add additional services or protocols to the Open Protocols of the payment terminal as approved and documented in the payment terminal vendor’s security guidance/policy. This includes the use of:</p><ul><li>Link Layer protocols</li><li>IP protocols</li><li>Security protocols</li><li>IP Services</li></ul></td><td><p>The Open Protocol requirements in the <em>PCI PTS POI Standard</em> ensure that open protocols and services in payment terminals do not have vulnerabilities that can be remotely exploited and yield access to sensitive data or sensitive resources in the payment terminal. The payment terminal vendor defines what protocols and services are supported by the payment terminal and provides guidance to their use.</p><p>Adding or enabling additional services or protocols or failing to follow the issued payment terminal vendor’s security guidance/policy invalidates the approval status of that device for that implementation.</p></td></tr><tr><td><p><strong>B.2.3 </strong>The software does not bypass or render ineffective any encryption methods or account data security methods implemented by the payment terminal in accordance with the payment terminal vendor’s security guidance/policy.</p></td><td><p><strong>B.2.3.a</strong> The assessor shall examine evidence (including source code) to determine whether the software provides encryption of sensitive data. Where the software does provide such a function, the assessor shall confirm the software does not bypass or render ineffective any encryption methods or account data security methods implemented by the payment terminal as follows:<strong></strong></p></td><td><p>Payment terminals are designed to provide robust cryptographic and key management functions. For example, PCI PTS POI-approved devices are verified to meet stringent requirements for loading, managing, and protecting cryptographic keys. Software that provides its own data encryption methods must not include methods that would enable an attacker to bypass or render ineffective the encryption methods implemented by the payment terminal and required by the payment terminal vendor’s security guidance/policy.</p></td></tr></tbody></table>

| **Control Objectives** | **Test Requirements** | **Guidance** |
| --- | --- | --- |
|     | **B.2.3.b** The assessor shall examine all relevant payment terminal documentation (including payment terminal vendor security guidance/policy)to determine which encryption methods are provided by the payment terminal. |     |
| **B.2.3.c** The assessor shall examine evidence (including source code) to confirm that the software does not bypass or render ineffective any encryption methods provided by the payment terminal in accordance with the payment terminal vendor’s security guidance/policy. |
| **B.2.3.d** Where the software provides encryption of sensitive data, but the payment terminal is not required to provide approved encryption methods (per the _PCI PTS POI Standard_), the assessor shall examine evidence (including source code) to confirm that the encryption methods used or implemented by the software for encrypting sensitive data provide “strong cryptography” and are implemented in accordance with Control Objectives 7.1 and 7.2. |
| **B.2.4** The software uses only the random number generation function(s) included in the payment terminal’s PTS device evaluation for all cryptographic operations involving sensitive data or sensitive functions where random values are required and does not implement its own random number generation function(s). | **B.2.4.a** The assessor shall examine evidence (including source code) to determine whether the software requires random values to be generated for any cryptographic operations involving sensitive data or sensitive functions. | The unpredictability of random numbers is of critical importance to ensure the effectiveness of cryptographic operations. It is not a trivial endeavor to design and implement a secure random number generator. For this reason, the terminal software should only use the random number generation function(s) implemented by the payment terminal for all cryptographic operations involving sensitive data or sensitive functions where random values are required. |
| **B.2.4.b** Where the software requires random values for cryptographic operations involving sensitive data or sensitive functions, the assessor shall examine all relevant payment terminal documentation (including payment terminal vendor security guidance/policy) to determine all of the random number generation functions included in the payment terminal’s PTS device evaluation. |

<table><tbody><tr><th><p><strong>Control Objectives</strong></p></th><th><p><strong>Test Requirements</strong></p></th><th><p><strong>Guidance</strong></p></th></tr><tr><td><p><strong></strong></p></td><td><p><strong>B.2.4.c</strong> The assessor shall examine evidence (including source code) to confirm that the software uses only the random number generation function(s) included in the payment terminal’s PTS device evaluation for all cryptographic functions involving sensitive data or sensitive functions where random values are required and does not implement its own random number generation function(s).<strong></strong></p></td><td><p></p></td></tr><tr><td rowspan="3"><p><strong>B.2.5</strong> The software does not provide, through its own logical interface(s), the sharing of clear-text account data directly with other software.</p><table><tbody><tr><th><p><strong><em>Note: </em></strong><em>The software is allowed to share clear-text account data directly with the payment terminal’s firmware.</em><strong><em></em></strong></p></th></tr></tbody></table><p><strong></strong></p><p><strong></strong></p></td><td><p><strong>B.2.5.a</strong> The assessor shall examine evidence (including source code) to determine all logical interfaces of the software, including:</p><ul><li>All logical interfaces and the purpose and function of each.</li><li>The logical interfaces intended for sharing clear-text account data, such as those used to pass clear-text account data back to the approved firmware of the payment terminal.</li><li>The logical interfaces not intended for sharing of clear-text account data, such as those for communication with other software.</li></ul></td><td rowspan="3"><p>Many payment terminals provide mechanisms for the secure reading and exchange of data (SRED). These mechanisms are rigorously tested as part of the payment terminal’s PTS device evaluation to confirm that the confidentially and integrity of cleartext account data is maintained during information exchange with the payment terminal’s firmware. Software that provides its own mechanisms for sharing clear-text account data directly with other software is more likely to be prone to attacks and the unintended or unauthorized disclosure of clear-text account data than software that uses the payment terminal-provided SRED (or similar) functions.</p><p></p><p></p></td></tr><tr><td><p><strong>B.2.5.b</strong> The assessor shall examine evidence (including source code) to confirm that the software does not allow sharing of clear-text account data directly with other software through its own logical interfaces.<strong></strong></p></td></tr><tr><td><p><strong>B.2.5.c</strong> The assessor shall install and configure the software in accordance with the guidance required in Control Objectives</p><p>12.1 and B.5.1. Using an appropriate “test platform” and suitable forensic tools and/or methods, the assessor shall test the software using all software functions that handle account data to confirm that the software does not allow the sharing of clear-text account data directly with other software through its own logical interfaces.<strong></strong></p></td></tr><tr><td><p><strong>Control Objectives</strong></p></td><td><p><strong>Test Requirements</strong></p></td><td><p><strong>Guidance</strong></p></td></tr><tr><td rowspan="2"><p><strong>B.2.6</strong> The software uses and/or integrates all shared resources securely and in accordance with the payment terminal vendor’s security guidance/policy.<strong></strong></p><p><strong></strong></p></td><td><p><strong>B.2.6.a</strong> The assessor shall examine evidence (including source code) to determine whether and how the software connects to and/or uses any shared resources provided by the payment terminal, and to confirm that:</p><ul><li>The guidance required in Control Objectives 12.1 and</li></ul><p>B.5.1 includes detailed instructions for how to configure the software to ensure secure integration with shared resources.</p><ul><li>The required guidance for secure integration with shared resources is in accordance with the payment terminal vendor’s security guidance/policy.</li></ul></td><td rowspan="2"><p>Where the software uses or integrates shared resources provided by the payment terminal, the software must use or integrate resources in accordance with the payment terminal vendor’s guidance/policy. Failure to use such shared resources in accordance with payment terminal guidance puts any sensitive data shared with such resources at greater risk of unauthorized disclosure.</p><p></p></td></tr><tr><td><p><strong>B.2.6.b</strong> The assessor shall install and configure the software in accordance with the guidance required in<strong> </strong>Control Objectives</p><p>12.1 and B.5.1. Using an appropriate “test platform” and suitable forensic tools and/or methods, the assessor shall test the software using all software functions that use or integrate shared resources to confirm that any connections to or use of shared resources are handled securely.<strong></strong></p></td></tr></tbody></table>

| **Control Objectives** | **Test Requirements** | **Guidance** |
| --- | --- | --- |
| **B.2.7** The software does not bypass or render ineffective any application segregation enforced by the payment terminal. | **B.2.7.a** The assessor shall examine all relevant payment terminal documentation (including the payment terminal vendor’s security guidance/policy) to determine whether and how application segregation is enforced by the payment terminal. | Many payment terminals enforce logical separation between software applications. In the context of this module, software applications are logical entities that do not meet the PTS definition of “firmware.”<br><br>Logical application segmentation controls are intended to prevent one application on the payment terminal from interfering or tampering with other applications. However, these logical segregation controls are not intended to prevent applications from sharing data. They are mainly intended to prevent applications from modifying the structure or function of other applications or the payment terminal’s firmware.<br><br>To preserve the integrity of payment terminal application-segregation controls, all terminal software should adhere to those segregation controls and not include or introduce any function(s) that would allow the software to be used (intentionally or unintentionally) to bypass or defeat device-level application segregation. |
| **B.2.7.b** The assessor shall examine evidence (including source code) to confirm that the software does not introduce any function(s) that would allow it to bypass or defeat any devicelevel application segregation controls. |
| **B.2.8** All software files are cryptographically signed to enable cryptographic authentication of the software files by the payment terminal firmware. | **B.2.8.a** The assessor shall examine the guidance required in Control Objectives 12.1 and B.5.1 to confirm that it includes detailed instructions for how to cryptographically sign the software files in a manner that enables the cryptographic authentication of all such files by the payment terminal. | To support cryptographic authentication of software files by the payment terminal, software vendors must cryptographically “sign” all of the software files (including all binaries, libraries, and configuration files) using digital certificates where the payment terminal vendor is included in the certificate chain. Additionally, the cryptographic signing process should incorporate the use of a secure cryptographic device (SCD), typically provided by the payment terminal vendor. Cryptographic signing should also be performed under dual control to protect the integrity of all cryptographic keys, software files, and the cryptographic signing process in general. |
| **B.2.8.b** The assessor shall install and configure the software in accordance with the guidance required in Control Objectives<br><br>12.1 and B.5.1. Using an appropriate “test platform” and suitable forensic tools and/or methods, the assessor shall confirm that all software files are cryptographically signed in a manner that enables the cryptographic authentication of all software files. |

| **Control Objectives** | **Test Requirements** | **Guidance** |
| --- | --- | --- |
|     | **B.2.8.c** Where the software supports the loading of files outside of the base software package(s), the assessor shall examine evidence and test the software to determine whether each of those files is cryptographically signed in a manner that enables the cryptographic authentication of those files by the payment terminal. For any files that cannot be cryptographically signed, the assessor shall justify why the inability to cryptographically sign such files does not adversely affect the security of the software or the underlying payment terminal. |     |
| **B.2.8.d** The assessor shall examine evidence (including source code) to determine whether and how the software supports EMV<sup>®</sup> payment transactions. Where EMV payment transactions are supported by the software, the assessor shall install and configure the software in accordance with the guidance required in Control Objectives 12.1 and B.5.1. Using an appropriate “test platform” and suitable forensic tools and/or methods, the assessor shall confirm that all EMV Certification Authority Public Keys are cryptographically signed in a manner that enables the cryptographic authentication of those files by the payment terminal. | Where terminal software supports EMV payment transactions, the EMV Certificate Authority public keys should also be signed and cryptographically authenticated using the same methods and procedures as the terminal software files. |
| **B.2.9** The integrity of software prompt files is protected in accordance with Control Objective B.2.8. | **B.2.9.a** The assessor shall examine evidence (including source code) to determine whether the software supports the use of data entry prompts and/or prompt files. Where the software supports such features, the assessor shall confirm the software protects the integrity of those prompts as defined in Test Requirements B.2.9.b through B.2.9.c. | Sensitive data (including PIN and other account data) captured and handled by the software and underlying payment terminal is often controlled using prompt files.<br><br>Prompt files are configuration files that control software display prompts. To preserve the integrity of the prompts, prompt files should be stored and managed securely. Anywhere clear-text data entry is allowed by the software, prompt controls should be implemented.<br><br>_(continued on next page)_ |
| **Control Objectives** | **Test Requirements** | **Guidance** |
|     | **B.2.9.b** The assessor shall examine the guidance required in Control Objectives 12.1 and B.5.1 to confirm that it includes detailed instructions for stakeholders to cryptographically sign all prompt files in a manner that enables the cryptographic authentication of all such files in accordance with B.2.8. | Many prompt files are stored within a secure boundary of the device, such as a Secure Chip or<br><br>Secure Element or within a Trusted Execution Environment. When prompt files are to be maintained in shared storage locations, the files should be cryptographically signed and authenticated by the payment terminal prior to installation or execution. |
| **B.2.9.c** The assessor shall install and configure the software in accordance with the guidance required in Control Objectives<br><br>12.1 and B.5.1. Using an appropriate “test platform” and suitable forensic tools and/or methods, the assessor shall confirm that all prompt files are cryptographically signed in a manner that enables the cryptographic authentication of those files by the payment terminal in accordance with B.2.8. |

<table><tbody><tr><th colspan="3"><p><strong>Control Objectives</strong></p></th><th><p><strong>Test Requirements</strong></p></th><th><p><strong>Guidance</strong></p></th></tr><tr><td colspan="5"><p><strong>Control Objective B.3: Terminal Software Attack Mitigation</strong></p><p>Software security controls are implemented to mitigate software attacks.<em></em></p></td></tr><tr><td colspan="3"><p><strong>B.3.1</strong> The software validates all user and other external inputs.</p></td><td rowspan="2"><p><strong>B.3.1.a</strong> The assessor shall examine evidence (including source code) to identify all locations where the software accepts input data from untrusted sources. For each instance, the assessor shall confirm that input data is required to conform to a list of expected characteristics and that all input that does not conform to the list of expected characteristics is rejected by the software or otherwise handled securely.<strong></strong></p></td><td rowspan="3"><p>Any terminal software functions that accept externally supplied data (directly or indirectly) is a potential attack vector, particularly when the data is processed by an interpreter.</p><p>Injection attacks are common for almost all types of software and are intended to manipulate input data in a way that causes software to behave unexpectedly or unintentionally. For example, software that accepts externally supplied information, such as a file name or file path to construct a search command, can be easily manipulated to disclose information about sensitive files and resources that were never intended to be accessed through the software interface. To protect against this and other types of injection attacks, all input data should be validated, filtered, and/or sanitized before the information is sent to any interpreter.</p><p>Inputs for terminal software tend to involve simple commands and data. Therefore, all terminal software input data should be validated against a defined and restricted set of acceptable values before passing the data to any command interpreter. Any data that is not explicitly identified as an acceptable value or an acceptable range of values should be rejected.</p></td></tr><tr><td></td><td><p><strong><em>Note: </em></strong><em>Control Objectives B.3.1 through B.3.3 are extensions of Control Objective 4.2. Validation of these control objectives should be performed at the same time.</em><strong><em></em></strong></p></td><td></td></tr><tr><td colspan="3"><p><strong></strong></p></td><td><p><strong>B.3.1.b</strong> The assessor shall install and configure the software in accordance with the guidance required in Control Objectives</p><p>12.1 and B.5.1. Using an appropriate “test platform” and suitable forensic tools and/or methods, the assessor shall test the software by attempting to supply each user or other external input with invalid or unexpected characteristics to confirm that the software validates all inputs and either rejects or securely handles all unexpected characteristics.<strong></strong></p></td></tr><tr><td colspan="3"><p><strong>B.3.1.1</strong> All string values are validated by the software.<strong></strong></p></td><td><p><strong>B.3.1.1.a</strong> The assessor shall examine evidence (including source code) to identify all terminal software functions where string values are passed as inputs, and to confirm that all strings are checked for text or data that can be erroneously or maliciously interpreted as a command.</p></td><td><p>Externally supplied inputs that can be interpreted as commands are particularly susceptible to injection attacks. Even if externally supplied inputs are processed or transformed in some way (for example, augmented with additional data or sanitized), they may still be susceptible.</p><p><em>(continued on next page)</em></p></td></tr><tr><td colspan="3"><p><strong>Control Objectives</strong></p></td><td><p><strong>Test Requirements</strong></p></td><td><p><strong>Guidance</strong></p></td></tr><tr><td colspan="3"><p></p></td><td><p><strong>B.3.1.1.b</strong> The assessor shall install and configure the software in accordance with the guidance required in Control Objectives</p><p>12.1 and B.5.1. Using an appropriate “test platform” and suitable forensic tools and/or methods, the assessor shall test the software by attempting to supply each of the identified functions with data that includes commands to confirm that the software either rejects such inputs or otherwise handles such inputs securely.</p></td><td><p>Therefore, all inputs that can be interpreted as commands must be handled securely so that the execution of any constructed commands is controlled, as opposed to blindly executing whatever commands are included in the string.</p></td></tr><tr><td colspan="3" rowspan="2"><p><strong>B.3.1.2</strong> The software checks inputs and rejects or otherwise securely handles any inputs that violate buffer size or other memory allocation thresholds.<strong></strong></p><p><strong></strong></p></td><td><p><strong>B.3.1.2.a </strong>The assessor shall examine evidence (including source code) to identify all software functions that handle buffers and process data supplied from untrusted sources. For each of the noted functions, the assessor shall confirm that each of the identified functions:</p><ul><li>Uses only unsigned variables to define buffer sizes.</li><li>Conducts checks to confirm that buffers are sized appropriately for the data they are intended to handle, including consideration for underflows and overflows.</li><li>Rejects or otherwise securely handles any inputs that violate buffer size or other memory allocation thresholds.</li></ul></td><td rowspan="2"><p>Payment terminals and terminal software often leverage low-level programming languages, such as C and C++. These languages allow the software to directly manipulate OS-level or hardware-level features and functions. Using low-level programming languages offers many benefits but also has several drawbacks. Low-level programming languages are susceptible to attacks that use low-level characteristics to manipulate the software or the underlying hardware. Buffer overflows and underflows are examples of these types of attacks.</p><p>To protect against buffer overflow attacks, all terminal software functions that define or control buffer sizes should compare the amount of data intended for those buffers with the buffer size. Data that violates buffer size thresholds (overflows and underflows) should be rejected or otherwise handled securely.</p></td></tr><tr><td><p><strong>B.3.1.2.b</strong> The assessor shall install and configure the software in accordance with the guidance required in Control Objectives</p><p>12.1 and B.5.1. Using an appropriate “test platform” and suitable forensic tools and/or methods, the assessor shall test the software by attempting to supply each noted function with inputs that violate buffer size thresholds to confirm that the software either rejects or securely handles all such attempts.<strong></strong></p></td></tr></tbody></table>

<table><tbody><tr><th><p><strong>Control Objectives</strong></p></th><th><p><strong>Test Requirements</strong></p></th><th><p><strong>Guidance</strong></p></th></tr><tr><td rowspan="2"><p><strong>B.3.2</strong> Return values are checked, and error conditions are handled securely.<strong></strong></p><p><strong></strong></p></td><td><p><strong>B.3.2.a</strong> Using information obtained in Test Requirement 1.2.a, the assessor shall examine evidence (including source code) to identify all software functions that handle sensitive data. For each of the noted software functions, the assessor shall confirm that each function:</p><ul><li>Checks return values for the presence of sensitive data.</li><li>Processes the return values in a way that does not inadvertently “leak” sensitive data.</li></ul></td><td rowspan="2"><p>Another common technique used by attackers to compromise sensitive data that is stored, processed, or transmitted by software is to manipulate the software in a way that generates unhandled exceptions.</p><p>Unhandled exceptions are error conditions that the software vendor has not anticipated and, therefore, has not factored into the software design. If an attacker can manipulate a software function that is known to handle sensitive data in a way that generates a condition that the software does not handle properly, it is possible that the software may output an error that includes sensitive data.</p><p>To protect against attacks involving unhandled exceptions, all terminal software functions handling sensitive data should include processes or routines that instruct the software how to treat unknown exceptions. These processes should determine what information to include in any error codes or values. The disclosure of sensitive data through error conditions or error reporting, whether intentional or accidental, should be avoided.</p></td></tr><tr><td><p><strong>B.3.2.b</strong> The assessor shall install and configure the software in accordance with the guidance required in Control Objectives</p><p>12.1 and B.5.1. Using an appropriate “test platform” and suitable forensic tools and/or methods, the assessor shall test each software function that handles sensitive data by attempting to manipulate the software in a manner that generates an unhandled exception to confirm that error conditions do not expose sensitive data.<strong></strong></p></td></tr><tr><td><p><strong>B.3.3</strong> Race conditions are avoided.<strong></strong></p></td><td><p><strong>B.3.3.a</strong> The assessor shall examine evidence (including source code) to identify all software functions that rely on synchronous processing. For each of the noted functions, the assessor shall confirm that protection mechanisms have been implemented in the software to mitigate race conditions.<strong></strong></p></td><td><p>Race conditions can arise when the software requires sequential processing of data to perform some software function. For example, a “time-of-use, time-of-check race condition” exists when a file is checked at one point and used immediately after, with the assumption that the previous check is still valid. This assumption may not be correct if the system allows the file to be modified in between.</p><p>If an attacker can identify and manipulate the software to take advantage of a race condition, they may be able to execute arbitrary code or generate other conditions that the attacker could exploit further.</p></td></tr><tr><td><p><strong>Control Objectives</strong></p></td><td><p><strong>Test Requirements</strong></p></td><td><p><strong>Guidance</strong></p></td></tr><tr><td><p><strong></strong></p></td><td><p><strong>B.3.3.b</strong> The assessor shall install and configure the software in accordance with the guidance required in Control Objectives</p><p>12.1 and B.5.1. Using an appropriate “test platform” and suitable forensic tools and/or methods, the assessor shall test each software function that relies on synchronous processing by attempting to generate a race condition (such as through specially crafted attacks intended to exploit the timing of synchronous events) to confirm that the software is resistant to such attacks.<strong></strong></p></td><td><p>To protect against race conditions, protection mechanisms should be implemented by the terminal software to control sequential processing more tightly. Using the example described above, a “locking” mechanism could be used to prevent updates to the file until the file can be processed completely.</p><p>Regardless of the methods used, any terminal software that requires sequential processing of data for its operation should implement protections to avoid race conditions.</p></td></tr></tbody></table>

<table><tbody><tr><th><p><strong>Control Objectives</strong></p></th><th><p><strong>Test Requirements</strong></p></th><th><p><strong>Guidance</strong></p></th></tr><tr><td colspan="3"><p><strong>Control Objective B.4: Terminal Software Security Testing</strong></p><p>The software is tested rigorously for vulnerabilities prior to each release.<em></em></p></td></tr><tr><td rowspan="2"><p><strong>B.4.1</strong> A documented process is maintained and followed for testing software for vulnerabilities prior to each update or release.</p><table><tbody><tr><th><p><strong><em>Note: </em></strong><em>This control objective is an extension of Control Objective 10.2. Validation of these control objectives should be performed at the same time.</em></p></th></tr></tbody></table><p><strong></strong></p></td><td><p><strong>B.4.1.a</strong> The assessor shall examine evidence to confirm that the software vendor maintains a documented process in accordance with Control Objective 10.2 for testing the software for vulnerabilities prior to each update or release, and that the documented process includes detailed descriptions of how the vendor tests for the following:</p><ul><li>The presence or use of any unnecessary ports and protocols.</li><li>The unintended storage, transmission, or output of any clear-text account data.</li><li>The presence of any default user accounts with default or static access credentials.</li><li>The presence of any hard-coded authentication credentials in code or in configuration files.</li><li>The presence of any test data or test accounts.</li><li>The presence of any faulty or ineffective software security controls.</li></ul></td><td rowspan="2"><p>Many software vulnerabilities are the result of the software vendor’s failure to remove test functions or data. These lingering functions and data can provide an attacker with a path to compromise the software.</p><p>Before software is released to the public, it must be tested to confirm that test functions and data are not included in the release version. Examples of such functions and data that must be explicitly removed prior to release include:</p><ul><li>Any communication ports or protocols that are not absolutely required for software operation.</li><li>Any functions that allow the unintended storage, transmission, or output of any cleartext account data.</li><li>Any hard-coded authentication credentials in code or configuration files.</li><li>Any test data or test user accounts.</li><li>Any faulty or ineffective software security controls and protection mechanisms.</li></ul><p></p></td></tr><tr><td><p><strong>B.4.1.b</strong> The assessor shall examine evidence to confirm that the software is tested for vulnerabilities prior to each release and that the testing covers the following:</p><ul><li>The presence or use of any unnecessary ports and protocols.</li><li>The unintended storage, transmission, or output of any clear-text account data.</li></ul><p><em>(continued on next page)</em></p></td></tr><tr><td><p><strong>Control Objectives</strong></p></td><td><p><strong>Test Requirements</strong></p></td><td><p><strong>Guidance</strong></p></td></tr><tr><td><p><strong></strong></p></td><td><p><strong>B.4.1.b</strong></p><ul><li>The presence of any default user accounts with static access credentials.</li><li>The presence of any hard-coded authentication credentials in code or in configuration files.</li><li>The presence of any test data or test accounts.</li><li>The presence of any faulty or ineffective software security controls.</li></ul><p></p></td><td><p></p></td></tr></tbody></table>

| **Control Objectives** |     |     | **Test Requirements** | **Guidance** |
| --- |     |     | --- | --- |
| **Control Objective B.5: Terminal Software Implementation Guidance**<br><br>The software vendor provides stakeholders with clear and thorough guidance on the secure implementation, configuration, and operation of the software on applicable payment terminals. |     |     |     |     |
| **B.5.1** The software vendor provides implementation guidance on how to implement and operate the software securely for the payment terminals on which it is to be deployed. |     |     | **B.5.1** The assessor shall examine evidence to confirm that guidance on how to securely implement and operate the software for all applicable payment terminals is provided to stakeholders in accordance with Control Objective 12.1. | Because many security features used by terminal software are provided by the underlying payment terminal, the terminal software vendor should include instructions in its implementation guidance on how to configure all the available security features of both the terminal software and underlying payment terminal where applicable. |
|     | **_Note_**_: This control objective is an extension of Control Objective 12.1. Validation of these control objectives should be performed at the same time._ |     |
| **B.5.1.1** Implementation guidance includes detailed instructions for how to configure all available security options and parameters of the software. |     |     | **B.5.1.1** The assessor shall examine evidence to confirm that the required guidance includes detailed instructions on how to configure all available security options and parameters of the software in accordance with Control Objective B.1.3. |
| **B.5.1.2** Implementation guidance includes detailed instructions for how to securely configure the software to use the security features and functions of the payment terminal where applicable. |     |     | **B.5.1.2** The assessor shall examine evidence to confirm that the required guidance includes detailed instructions on how to securely configure the software to use the security features and functions of the payment terminal where applicable. |
| **B.5.1.3** Implementation guidance includes detailed instructions for how to configure the software to securely integrate or use any shared resources provided by the payment terminal. |     |     | **B.5.1.3** The assessor shall examine evidence to confirm that the required guidance includes detailed instructions on how to configure the software to securely integrate or use any shared resources provided by the payment terminal in accordance with Control Objective B.2.6. |

| **Control Objectives** | **Test Requirements** | **Guidance** |
| --- | --- | --- |
| **B.5.1.4** Implementation guidance includes detailed instructions on how to cryptographically sign the software files in a manner that enables the cryptographic authentication of all such files by the payment terminal. | **B.5.1.4** The assessor shall examine evidence to confirm that the required guidance includes detailed instructions on how to cryptographically sign the software files in a manner that enables the cryptographic authentication of all such files by the payment terminal in accordance with Control Objective B.2.8. |     |
| **B.5.1.5** Implementation guidance includes instructions for stakeholders to cryptographically sign all prompt files. | **B.5.1.5** The assessor shall examine evidence to confirm that the required guidance includes detailed instructions for stakeholders to cryptographically sign all prompt files in accordance with Control Objective B.2.9. |
| **B.5.2** Implementation guidance adheres to payment terminal vendor guidance on the secure configuration of the payment terminal. | **B.5.2** The assessor shall examine evidence (including the payment terminal vendor’s security guidance/policy and the guidance required in Control Objective B.5.1) to confirm that the guidance aligns with the payment terminal vendor’s security guidance/policy. | Software implementation guidance must exclude instructions that conflict with the guidance and recommendations of the payment terminal vendor. Software implementation guidance must align with the payment terminal vendor’s security<br><br>guidance/policy. Otherwise, software users who rely on the software vendor for instructions may unknowingly configure the software and/or the underlying payment terminal improperly. |

## Module C – Web Software Requirements

| **Module Name** | **Overview** | **Control Objectives** |
| --- | --- | --- |
| **Module C: Web Software Requirements** | Additional security requirements for payment software that uses Internet technologies, protocols, and languages to initiate or support electronic payment transactions. | **C.1**: Web Software Components & Services<br><br>**C.2**: Web Software Access Controls<br><br>**C.3:** Web Software Attack Mitigation<br><br>**C.4**: Web Software Communications |

### Purpose and Scope

This section (hereinafter referred to as the “Web Software Module” or “this module”) defines security requirements and assessment procedures for payment software and applications that use Internet technologies, protocols, and languages for the purposes of initiating or supporting electronic payment transactions. This includes both traditional (monolithic) and cloud-native payment applications, APIs, web services, microservices, serverless functions, GRPC, and any other methods used to make payment functions accessible or to conduct electronic payment transactions over the Internet. Any software-based features or functions that handle requests from Internet “clients” and generate responses to initiate or support an electronic payment transaction are in scope for the requirements in this module.

### Considerations

Web software architectures can be extremely complex and involve features and functions that are provided by different entities and may be distributed across different geographic locations. The security issues affecting web software can vary significantly. The security requirements defined within this web module do not address all risks affecting web-based payment software. They are intended as a minimum set of security characteristics, controls, features, and capabilities that web-based payment software must possess to defend itself from the most common attacks on web software.

While many of the control objectives defined in this standard protect against new and/or novel attacks beyond the most common techniques, attacks will inevitably evolve or emerge that will require new methods or approaches to mitigate them. It is ultimately the responsibility of payment software vendors, providers, developers, and suppliers to keep abreast of evolving attacks techniques and to implement appropriate security controls to enable their software to defend against such attacks.

### Security Requirements

<table><tbody><tr><th><p><strong>Control Objectives</strong></p></th><th><p><strong>Test Requirements</strong></p></th><th><p><strong>Guidance</strong></p></th></tr><tr><td colspan="3"><p><strong>Control Objective C.1: Web Software Components &amp; Services</strong></p><p>All components and services used by the software are identified and maintained in a manner that minimizes the exposure of vulnerabilities.</p></td></tr><tr><td><p><strong>C.1.1</strong> All software components and services are documented or otherwise cataloged in a software bill of materials (SBOM).</p></td><td><p><strong>C.1.1</strong> The assessor shall examine evidence to confirm that information is maintained that describes all software components and services comprising the software solution, including:</p><ul><li>All proprietary software libraries, packages, modules, and/or code packaged in a manner that enables them to be tracked as a freestanding unit of software.</li><li>All third-party and open-source frameworks, libraries, and code embedded in or used by the software during operation.</li><li>All third-party software dependencies, APIs, and services called by the software during operation.</li></ul></td><td><p>Modern software is rarely created entirely in-house and is typically composed of various bespoke code segments integrated with numerous components such as commercial and/or open-source frameworks, libraries, APIs, and services. Any part of this code may have or develop vulnerabilities over time that will require patching or mitigation.</p><p>Knowing all of the components that comprise a software application or service, where they come from, and how they are updated and maintained is critical to minimizing and managing vulnerabilities in software applications. Without this information, it would be extremely difficult to identify and track vulnerabilities in software components that could expose the embedding software application to attacks.</p><p>A Software Bill of Materials or “SBOM” services this purpose by documenting information about the software components and versions used to create a software product, their suppliers, and any third-party</p><p>code that may also be embedded in these components. NIST refers to this information as “provenance data” and there are numerous standards and frameworks available, such as CycloneDX, SPDX and SWID, that describe how this</p><p>information should be structured. For more information, refer to those standards and frameworks.</p></td></tr></tbody></table>

| **Control Objectives** | **Test Requirements** | **Guidance** |
| --- | --- | --- |
| **C.1.2** The SBOM describes each of the primary components and services in use, as well as their secondary transitive component relationships and dependencies to the greatest extent feasible. | **C.1.2.a** The assessor shall examine evidence to confirm that the SBOM describes all primary (top-level) components and services in use and all of their secondary transitive relationships and dependencies. | Software components and services may have many nested relationships and dependencies with other software components and services that are owned or maintained by multiple different entities. Identifying all of these different relationships can be challenging where there are many different third-party components nested in the software code.<br><br>Fortunately, many software development frameworks and compilers provide the capabilities to identify and map nested and transient dependencies. For the purposes of this standard, the SBOM is expected to identify, at a minimum, the code obtained from third parties as well as their secondary transitive component relationships and dependencies (i.e., code embedded in third-party code).<br><br>If circumstances exist that complicate or prevent the identification of secondary transitive component relationships and dependencies, then such circumstances should be documented, and reasonable justification should be maintained to explain why these dependencies are not accurately reflected in the SBOM. Examples of such circumstances may include third-party APIs, where transparency into nested third-party components called by or embedded into those APIs is not provided by the API provider. |
| **C.1.2.b** The assessor shall test the software to confirm that the information provided in the SBOM accurately reflects the software components and services in use during software operation, including both primary components and services as well as their secondary transitive component relationships and dependencies. Where such dependencies and relationships are not identified and described in the SBOM, the assessor shall confirm that the absence of such information is justified and reasonable. |
| **C.1.3** Where the software is provided “as a service,” the SBOM includes information describing the software dependencies present in the production software execution environment to the greatest extent feasible. | **C.1.3.a** The assessor shall examine evidence to confirm that the SBOM describes all dependencies present in the production software execution environment that the software relies upon for operation or to satisfy security requirements in this standard. | Software that is provided “as a service” often involves the use of components and services resident in the production environment that are unique to that environment. To ensure that these dependencies and relationships are identified and tracked and vulnerabilities in these components and services identified and mitigated, these components and services must be also included in the SBOM.<br><br>_(continued on next page)_ |

<table><tbody><tr><th><p><strong>Control Objectives</strong></p></th><th><p><strong>Test Requirements</strong></p></th><th><p><strong>Guidance</strong></p></th></tr><tr><td><p><strong></strong></p></td><td><p><strong>C.1.3.b</strong> The assessor shall examine evidence and test the software (to the extent possible) to confirm that the information provided in the SBOM accurately reflects the software dependencies present in the production software execution environment. Where such dependencies are not identified and described in the SBOM, the assessor shall confirm that the absence of such information is justified and reasonable.<strong></strong></p></td><td><p>Examples of these types of components include, but are not limited to, database servers, web servers, application servers, runtime platform(s),</p><p>authentication servers/services, "plugins", and any other components or services present in the production environment.</p></td></tr><tr><td rowspan="2"><p><strong>C.1.4 </strong>The SBOM includes sufficient information about each component or service to enable tracking each component or service across the software supply chain.<strong></strong></p></td><td><p><strong>C.1.4.a </strong>The assessor shall examine evidence to confirm that information is maintained in the SBOM that describes the following for each component and service in use, including secondary component relationships and dependencies:</p><ul><li>The original source/supplier of the component or service.</li><li>The name of the component or service as defined by the original supplier.</li><li>A description of the relationship(s) between the component and service and other components/services embedded in or used by the software.</li><li>The version of the component or service as defined by the original supplier to differentiate it from previous or other versions.</li><li>The name of the author who designed/developed the component or service.</li><li>Any other identifiers provided by the original supplier to uniquely identify the component or service.<strong></strong></li></ul></td><td rowspan="2"><p>The primary purpose of an SBOM is to enable the tracking of software components across the software supply chain and to map them to repositories containing vulnerability information about these components. To facilitate tracking components for these purposes, information must be included in the SBOM that enables software stakeholders to:</p><ul><li>Uniquely identify each of the components and services used by the software.</li><li>Uniquely identify different versions of the same software components and services that may be used by the software, and to differentiate them from other versions of the same software components and services made available by the supplier(s).</li><li>Locate the sources of these components and services such that updated versions may be downloaded, installed, and/or referenced where applicable.</li></ul><p>Without this basic information, tracking vulnerabilities and available patches in these components and services may be extremely difficult, if not impossible.</p></td></tr><tr><td><p><strong>C.1.4.b</strong> The assessor shall examine evidence and test the software to confirm that the information provided in the SBOM is an accurate representation of the software components and services present in and/or in use by the software.<strong></strong></p></td></tr></tbody></table>

| **Control Objectives** | **Test Requirements** | **Guidance** |
| --- | --- | --- |
| **C.1.5** A new SBOM is created or generated each time the software is updated. | **C.1.5** The assessor shall examine evidence to confirm that a new SBOM is created or otherwise generated for each new release of the software. | To enable tracking of vulnerabilities across different versions of a payment software, it is imperative that each version of the software has a SBOM generated that accurately reflects the components and services in use by that version.<br><br>Since many different versions of a payment software may be available (or active) at any given time and may include multiple versions of numerous thirdparty components and services, each version of the payment software must be tracked independently of other versions.<br><br>Failure to identify and describe the components and services unique to a given version of payment software could enable vulnerabilities to be introduced without the software provider’s knowledge if they are unaware that a vulnerable version of a software component or service is in use. |
| **C.1.6** Vulnerabilities in third-party components and services are monitored and managed in accordance with Control Objective 10. | **C.1.6.a** The assessor shall examine evidence to confirm that third-party components and services present in and/or in use by<br><br>the software are regularly monitored for vulnerabilities in accordance with Control Objective 10.1. | Vulnerabilities in third-party components and services must be handled in the same manner as vulnerabilities in vendor-controlled code. They must be monitored for vulnerabilities through testing and/or the monitoring of publicly available vulnerability disclosure repositories and managed such that any known vulnerabilities in those components and services are patched, or otherwise mitigated, as quickly as possible.<br><br>Failure to patch or mitigate a vulnerability in thirdparty components or services can have the same ramifications as a failure to patch or mitigate a vulnerability in the payment software vendor’s own code. |
| **C.1.6.b** The assessor shall examine evidence to confirm that vulnerabilities in third-party components and services are identified and are patched or otherwise mitigated in a timely manner in accordance with Control Objective 10.2. |

| **Control Objectives** | **Test Requirements** | **Guidance** |
| --- | --- | --- |
| **C.1.7** Where software components and/or resources are hosted or maintained on third-party systems, such as content delivery networks (CDN), the authenticity of those components and resources is verified each time they are fetched. | **C.1.7.a** Where software components and resources are fetched from external and/or third-party repositories, the assessor shall examine evidence to confirm that the authenticity of the software component is verified each time the component is fetched. | It is a common architectural design technique in modern web applications to download or “fetch” third-party components and resources (for example, files, scripts, stylesheets, packages, and libraries) that are housed on publicly available code repositories (such as public content delivery networks) at the time they are needed rather than embedding and maintaining those components and resources in local code repositories. This technique provides many benefits including the ability to automatically deploy updates to third-party components and resources without necessarily having to recompile code.<br><br>Unfortunately, there are some significant drawbacks to this approach. Third-party code repositories are heavily targeted by attackers because it enables them to potentially compromise numerous applications and entities by compromising a single package, library, script, or function. For example, if a malicious individual were able to compromise these repositories or otherwise replace a widely used JavaScript library with a modified version, then that malicious library could be automatically propagated to every user of that library without their knowledge.<br><br>To mitigate the risk of fetching malicious versions of code from third-party repositories, payment software vendors must validate the authenticity of such components before they are fetched (and/or loaded) by the calling application.<br><br>There are numerous ways in which this can be accomplished, but the most common method of verifying a component’s authenticity is through strong cryptography and digital signatures. |
| **C.1.7.b** The assessor shall test the software to confirm that the authenticity of all software components and resources fetched from third-party systems or repositories is verified each time they are fetched by the software. |

| **Control Objectives** | **Test Requirements** | **Guidance** |
| --- | --- | --- |
| **Control Objective C.2: Web Software Access Controls**<br><br>Software security controls are implemented to restrict access to Internet-accessible interfaces, functions, and resources to explicitly authorized users only. |     |     |
| **C.2.1** User access to sensitive functions and sensitive resources exposed through Internet-accessible interfaces is authenticated. | **C.2.1** Using information obtained in Test Requirements 1.2.a and 2.1.a in the Core Requirements, the assessor shall examine<br><br>evidence to identify all sensitive functions and sensitive resources exposed through Internet-accessible interfaces. | Writing custom authentication functions is not a trivial matter. There are numerous issues and considerations that must be factored into the design and implementation of such functions including, but not limited to, the fact that they are a significant target for attackers. Authentication functions must be free from weaknesses in design and must be resistant to targeted attacks.<br><br>Given the importance of and the heavy reliance on such functions for security purposes (and those of this standard), it is recommended that entities use third-party authentication functions, modules, libraries, services, and so on, that are already widely used within the industry and have been subjected to thorough security testing and scrutiny.<br><br>Where the use of such mechanisms is not feasible, then custom methods may be used. However, custom methods must be designed and implemented<br><br>in strict accordance with applicable industry standards or best practices for authentication. Failure to do so could expose vulnerabilities or design weaknesses in custom authentication methods to malicious entities who may exploit those vulnerabilities to manipulate or otherwise bypass custom authentication mechanisms. |

<table><tbody><tr><th><p><strong>Control Objectives</strong></p></th><th><p><strong>Test Requirements</strong></p></th><th><p><strong>Guidance</strong></p></th></tr><tr><td rowspan="4"><p><strong>C.2.1.1</strong> The methods implemented to authenticate user access to sensitive functions and sensitive resources use industry-standard mechanisms.<strong></strong></p></td><td><p><strong>C.2.1.1.a</strong> The assessor shall examine evidence to identify all methods implemented by the software to authenticate access to sensitive functions and sensitive resources.<strong></strong></p></td><td rowspan="4"><p>Similar to developing one’s own authorization mechanisms, developing custom authentication mechanisms can be quite a complex undertaking. Much of an application’s security is dependent on the strength and robustness of its authentication and authorization mechanisms. There are numerous issues and considerations that must be factored into the design and implementation of such functions including but not limited to, the fact that they are a significant target for attackers. Authentication functions must be free from weaknesses and must be able to withstand targeted attacks.</p><p>For this reason, only well-designed and well-tested mechanisms should be used. Authentication mechanisms that are provided by industry-accepted suppliers and widely adopted within the industry are generally understood to have been subjected to substantial testing and validation throughout the course of that adoption. Therefore, it is strongly recommended that these mechanisms be used by other entities instead of writing and implementing their own mechanisms.</p><p>Where the use of third-party mechanisms is not feasible, then custom methods may be used. However, custom methods must be designed and implemented in strict accordance with applicable industry standards or best practices for authentication. Failure to do so could expose vulnerabilities or design weaknesses in custom authentication methods to malicious entities who may exploit those vulnerabilities to manipulate, or otherwise bypass the custom authentication mechanisms, rendering all such functions effectively useless.</p></td></tr><tr><td><p><strong>C.2.1.1.b</strong> The assessor shall examine evidence to confirm that the implemented methods use industry-standard mechanisms that are:</p><ul><li>Provided by well-known and industry-accepted third-party suppliers; or</li><li>Designed and implemented in accordance with applicable industry standards or best practices.</li></ul></td></tr><tr><td><p><strong>C.2.1.1.c</strong> Where sessions are used to authenticate user access to sensitive functions and sensitive resources, the assessor shall examine evidence to confirm that the sessions are handled in accordance with industry-recognized standards and best practices for secure session management.<strong></strong></p></td></tr><tr><td><p><strong>C.2.1.1.d</strong> Where tokens (for example, access tokens and refresh tokens) are used to authenticate user access to sensitive functions and sensitive resources, the assessor shall examine evidence to confirm that the tokens are handled in accordance with industry-recognized standards and best practices for secure token management.<strong></strong></p></td></tr></tbody></table>

| **Control Objectives** | **Test Requirements** | **Guidance** |
| --- | --- | --- |
| **C.2.1.2** The methods implemented to authenticate user access to sensitive functions and sensitive resources through Internetaccessible interfaces are sufficiently strong and robust to protect authentication credentials in accordance with Control Objective 5.3. | **C.2.1.2** Using information obtained in Test Requirement<br><br>C.2.1.1.a, the assessor shall examine evidence to confirm that the authentication methods implemented are sufficiently strong and robust to protect authentication credentials in accordance with Control Objective 5.3 in the Core Requirements section. | Strong and robust authentication methods are those that are resistant to common attacks. Examples of such methods include, but are not limited to, multifactor authentication and/or authentication methods that employ strong cryptography (such as digital signatures or certificates). |
| **C.2.1.3** Authentication decisions are enforced within a secure area of the software. | **C.2.1.3.a** The assessor shall examine evidence to identify where within the software architecture authentication decisions are enforced. | Like authorization decisions, authentication decisions must be enforced within a secure area of the software. Authentication methods should never rely solely on scripts or data obtained from the client or browser. With that said, it is permissible to use client-side scripts and data when combined with server-side methods to enhance authentication capabilities. |
| **C.2.1.3.b** The assessor shall examine evidence to confirm that all authentication decisions are enforced within a secure area of the software architecture. |
| **C.2.1.3.c** The assessor shall examine evidence and test the software to confirm that client-side or browser-based functions, scripts, and data are never solely relied upon for authentication purposes. |
| **C.2.2** Access to all Internetaccessible interfaces is restricted to explicitly authorized users only. | **C.2.2.a** Using information obtained in Test Requirement 2.1.a in the Core Requirements section, the assessor shall examine evidence to identify all software interfaces that are exposed to the Internet or that can be configured in a way that exposes them to the Internet. | Modern web applications, particularly those that rely heavily on APIs, microservices and serverless environments, require fine-grained access control capabilities to handle the increasingly complex relationships between software users, interfaces, functions, and resources.<br><br>_(continued on next page)_ |
| **C.2.2.b** The assessor shall examine evidence to identify all methods used to authorize access to Internet-accessible interfaces. |

<table><tbody><tr><th><p><strong>Control Objectives</strong></p></th><th><p><strong>Test Requirements</strong></p></th><th><p><strong>Guidance</strong></p></th></tr><tr><td rowspan="4"></td><td><p><strong>C.2.2.c</strong> The assessor shall examine evidence and test the software to confirm that each of these methods is:</p><ul><li>implemented correctly;</li><li>appropriate for the types of users expected to use the interface; and</li><li>does not expose known vulnerabilities.<strong></strong></li></ul></td><td rowspan="4"><p>One key difference between traditional “monolithic” web applications and modern web applications is the degree to which an application is exposed (or potentially exposed) to the Internet. Where monolithic web applications tend to keep interactions between software components confined to a single security context (such as an internal or isolated system or network), modern web applications are typically segmented into many distinct and/or independent software functions that are then exposed to the Internet through APIs so that they may be accessible to other application or users, regardless of where they may reside.</p><p>Unfortunately, each Internet accessible interface (and the functions and resources it provides) is a potential attack vector. To mitigate the risks associated with exposing so many software functions to the Internet, each interface must implement access control mechanisms to ensure that only authorized systems and users are able to access the interface, and the functions and resources exposed through those interfaces.</p></td></tr><tr><td><p><strong>C.2.2.d</strong> Where the methods used to authorize access to</p><p>Internet-accessible interfaces is user configurable, or otherwise requires user input or interaction, the assessor shall examine evidence to confirm that appropriate guidance is made available to stakeholders in accordance with Control Objective 12.1 that describes the configurable options available and how to configure each method securely.<strong></strong></p></td></tr><tr><td><p><strong>C.2.2.e</strong> Where the methods used to authorize access to Internet-accessible interfaces are configured and controlled by the assessed entity, the assessor shall examine evidence to confirm that access to Internet-accessible interfaces is restricted to an appropriate set of explicitly authorized users (or entities).<strong></strong></p></td></tr><tr><td><p><strong>C.2.2.f</strong> The assessor shall examine evidence and test the software to confirm that access to all Internet-accessible interfaces is restricted to explicitly authorized users only.<strong></strong></p></td></tr><tr><td><p><strong>C.2.3</strong> Access to all software functions and resources exposed through Internet-accessible interfaces is restricted to explicitly authorized users only.<strong></strong></p></td><td><p><strong>C.2.3</strong> Using information obtained in Test Requirement C.2.2.a, the assessor shall examine evidence to identify all software functions and resources that are exposed, or that can be configured in a way that exposes them, through Internetaccessible interfaces.<strong></strong></p></td><td><p>In addition to controlling access at the interfacelevel, access to individual functions and resources provided through each Internet accessible interface must also be controlled.</p><p>Access needs to the different functions and resources within a given interface can be quite complex depending upon the types of users and systems that need to use a given interface and the different capabilities and data accessible through those functions and resources.</p></td></tr></tbody></table>

<table><tbody><tr><th><p><strong>Control Objectives</strong></p></th><th><p><strong>Test Requirements</strong></p></th><th><p><strong>Guidance</strong></p></th></tr><tr><td rowspan="2"><p><strong>C.2.3.1</strong> The software ensures the enforcement of access control rules at both the function level and resource level with fine-grained access control capabilities.<strong></strong></p></td><td><p><strong>C.2.3.1.a </strong>Using information obtained in Test Requirement C.2.3, the assessor shall examine evidence to determine how the software controls access to individual functions and resources exposed (or potentially exposed) through Internet-accessible interfaces.<strong></strong></p></td><td rowspan="2"><p>To support the fine-grained access control needs of modern web application architectures and to ensure that users are only able to access the software functions and resources that they are authorized to use, the software must support the ability to define and enforce access control rules at varying “levels”</p></td></tr><tr><td></td></tr><tr><td rowspan="2"></td><td><p><strong>C.2.3.1.b</strong> The assessor shall then examine evidence to identify the methods used to restrict access to the functions and resources exposed (or potentially exposed) through Internetaccessible interfaces and to confirm that each of these methods is:</p><ul><li>implemented correctly;</li><li>appropriate for the type of function(s) and resource(s) provided; and</li><li>does not expose known vulnerabilities.</li></ul></td><td rowspan="2"><p>within the interface’s hierarchy, including at the individual function and resource level(s).</p><p>Depending upon the types of functions and resources exposed in a given software interface, the methods used to authorize access at the interfacelevel may not be appropriate to provide access to individual functions and resources exposed through such interfaces.</p><p>For example, API keys are often used to authorize access to an API for a particular entity (also called project-level or entity-level authorization). While API keys may be suitable for authorizing this level of access to an API, it may not be suitable for authorizing individual user access to specific functions or resources exposed (or potentially exposed) through the API.</p><p><em>(continued on next page)</em></p></td></tr><tr><td><p><strong>C.2.3.1.c</strong> Where the methods used to authorize access to the functions and resources exposed (or potentially exposed) through Internet-accessible interfaces are user configurable or otherwise requires user input or interaction, the assessor shall examine evidence to confirm that guidance is made available to stakeholders in accordance with Control Objective 12.1 that describes the mechanisms and configurable options available to restrict access to the functions and resources exposed through these interfaces, and how to configure such mechanisms.<strong></strong></p></td></tr></tbody></table>

| **Control Objectives** | **Test Requirements** | **Guidance** |
| --- | --- | --- |
|     | **C.2.3.1.d** Where the methods used to authorize access to the functions and resources exposed (or potentially exposed) through Internet-accessible interfaces is configured and controlled by the assessed entity, the assessor shall examine evidence to confirm that access to the functions and resources is restricted to an appropriate set of explicitly authorized users. | Where fined-grained access control is necessary, the methods implemented to control access to all software functions and resources exposed through Internet accessible interfaces must be appropriate for the types of authorization(s) required (for example, user versus entity) and the functions and resources involved (sensitive versus non-sensitive functions and resources).<br><br>Wherever end users are required to configure the access control authorizations and permissions for individual functions and resources exposed through Internet accessible interfaces, the software vendor must provide guidance (or otherwise make guidance accessible) to users and other stakeholders to explain how to configure such permissions and to alert them to important security considerations when configuring available options and parameters. |
| **C.2.3.1.e** The assessor shall examine evidence and test the software to confirm that the methods used to restrict access to the functions and resources exposed (or potentially exposed) through Internet-accessible interfaces require users to be explicitly authorized prior to being granted such access. |
| **C.2.3.2** Authorization rules are enforced upon each user request to access software functions and resources through Internetaccessible interfaces. | **C.2.3.2.a** Using information obtained in Test Requirement<br><br>C.2.3.1.a, the assessor shall examine evidence to confirm that authorization checks are performed each time users request access to a function or resource exposed (or potentially exposed) through Internet-accessible interfaces to verify they are authorized for the function, resource, and type of access requested. | Most modern web applications, particularly those that use APIs, microservices and serverless architectures, operate on a request/response basis. Each time a user wants to perform a function or access application data, they submit a request to the application (usually through an API or similar) to access a particular function or resource. The software then processes that request and, if authorized, executes the requested function and/or returns the requested data.<br><br>It is often trivial for attackers to obtain login credentials of authorized users. A defense-in-depth strategy is essential to ensuring that only authorized users can access protected functions and resources. When combined with other security controls, such as expiring sessions or tokens after a relatively short period of time, authorization checks can significantly limit what an attacker can do if they are able to compromise the credentials of an authorized user. |
| **C.2.3.2.b** The assessor shall examine evidence and test the software to confirm that access control rules are enforced each time a user attempts to access a function or resource exposed<br><br>(or potentially exposed) through Internet-accessible interfaces. |

| **Control Objectives** | **Test Requirements** | **Guidance** |
| --- | --- | --- |
| **C.2.3.3** Access control decisions are enforced within a secure area of the software architecture. | **C.2.3.3.a** The assessor shall examine evidence to identify where in the software architecture authorization and access control decisions are enforced. | Payment software should never rely on unknown or insecure services and features for security-related purposes. Secure areas or systems are those within the software architecture where the integrity of available services and data is ensured, and therefore can be relied upon by the software.<br><br>Historically, web application architectures consisted of “client-side” components and “server-side” components. Client-side functions are those typically performed by a common web browser. Server-side functions are those typically performed by web, application, and/or database servers. Given the open nature and design of most common web browsers and the fact that they are maintained by end users, server-side functions are typically considered to be more secure given a software/service provider’s ability to control and secure those aspects of the software architecture.<br><br>Modern web software architectures, however, have become increasingly complex with software components often deployed across multiple geographic locations and managed by multiple entities. In these circumstances, the distinction between “client-side” or “server-side” functions can be increasingly ambiguous. The term “secure area” is a reference to traditional “server-side” functions without getting into architectural specifics. Examples of a secure area include a secured server environment, a microservice, or a serverless API. |
| **C.2.3.3.b** The assessor shall examine evidence to confirm that all access control decisions are enforced within a secure area of the software architecture. |
| **C.2.3.3.c** The assessor shall examine evidence and test the software to confirm that client-side or browser-based functions, scripts, and data are never solely relied upon for access control purposes. |

| **Control Objectives** | **Test Requirements** | **Guidance** |
| --- | --- | --- |
| **Control Objective C.3: Web Software Attack Mitigation**<br><br>Software security controls are implemented to mitigate common attacks on web applications. |     |     |
| **C.3.1** The software enforces or otherwise supports the use of the latest HTTP Security Headers to protect Internet accessible interfaces from attacks. | **C.3.1.a** The assessor shall examine evidence to confirm the software supports the use of the latest HTTP Security Headers, and to determine the options available and how such settings are configured. | HTTP Security Headers are a set of security-related configuration options available on most common web servers. Examples include the X-Frame-Options header, the HTTP-Strict-Transport-Security header, and the Content-Security-Policy header.<br><br>The use of these options can protect against a variety of different types of attacks including crosssite scripting, clickjacking, and cross-site request forgery attacks.<br><br>While support for specific HTTP Security Headers may differ depending on the underlying platform or software technology, these options are widely available and should be enabled and configured to the most secure configuration feasible for a given implementation. |
| **C.3.1.b** Where HTTP Security Headers are configured and controlled by the software provider, the assessor shall examine evidence to confirm that the software is configured to use the latest available HTTP Security Headers and that the configuration settings are reasonable and justified. |
| **C.3.1.c** Where user input or interaction is required to configure HTTP Security Headers, the assessor shall examine evidence to confirm that guidance is made available to stakeholders in accordance with Control Objective 12.1 that describes the HTTP Security Headers supported by the software and how to configure such settings. |
| **C.3.2** Input data from untrusted sources is never trusted and software security controls are implemented to mitigate the exploitation of vulnerabilities through the manipulation of input data. | **C.3.2.a** Using information obtained in Test Requirement C.2.1.a, the assessor shall examine evidence to identify all interfaces that accept data input from untrusted sources. | Many vulnerabilities in software and systems are exposed when input data supplied by an untrusted source is inherently trusted by the software and is processed without first ensuring the data is safe.<br><br>Untrusted sources are those that reside in a different security context than the API or system receiving and processing the input data. Examples of an untrusted source could include a system, API, or microservice residing in a different environment, an internal system that resides on the same network but is maintained under a lower security classification, or a user’s browser.<br><br>_(continued on next page)_ |
| **C.3.2.b** Where the software accepts input from untrusted sources, the assessor shall examine evidence to identify the data format(s) expected by the software for each input field and the parsers and interpreters involved in processing the input data. |

| **Control Objectives** | **Test Requirements** | **Guidance** |
| --- | --- | --- |
|     | **C.3.2.c** Using information obtained in Test Requirement 4.1.a in the Core Requirements section, the assessor shall examine evidence to determine whether attacks that target all such parsers and interpreters are acknowledged in the threat model. | Two of the most common types of attacks, Injection<br><br>(SQL, XML, Code, String, and so on) and Cross-Site Scripting (XSS), exploit the software’s trust in input data provided by untrusted sources to execute malicious code or to force the software to behave in unintended ways.<br><br>To protect against these and other types of related attacks, input data must never be trusted, and software security controls must be implemented to ensure input data is validated, rendered safe, or otherwise handled in a manner that mitigates the likelihood and/or impacts of executing malicious input data. |
| **C.3.2.d** Where such attacks are acknowledged and using information obtained in Test Requirement 4.2.a in the Core Requirements section, the assessor shall examine evidence to confirm that software security controls are defined and implemented to mitigate attacks that attempt to exploit vulnerabilities through the manipulation of input data. |
| **C.3.2.e** Where the implementation of software security controls is configurable or otherwise requires user input or interaction, the assessor shall examine evidence to confirm that guidance is made available to stakeholders in accordance with Control Objective 12.1 that describes how to properly configure such security controls. |
| **C.3.2.1** Industry-standard methods are used to protect software inputs from attacks that attempt to exploit vulnerabilities through the manipulation of input data. | **C.3.2.1.a** Using information obtained in Test Requirement 4.2.a in the Core Requirements section, the assessor shall examine evidence to identify all software security controls implemented to mitigate attacks that attempt to exploit vulnerabilities through the manipulation of input data. | There are a variety of methods and techniques that may be used to protect software inputs from injection and other similar types of attacks. The method most often associated with such protections is “input validation.” Input validation, however, is difficult to implement correctly, particularly where complex input data, such as URLs, XML, JSON, serialized objects, and so on, are involved. Therefore, input validation is not appropriate as a primary defense against input manipulation attacks.<br><br>_(continued on next page)_ |

<table><tbody><tr><th><p><strong>Control Objectives</strong></p></th><th><p><strong>Test Requirements</strong></p></th><th><p><strong>Guidance</strong></p></th></tr><tr><td rowspan="2"><p><strong></strong></p></td><td><p><strong>C.3.2.1.b</strong> The assessor shall examine evidence to confirm that the methods implemented to protect against such attacks use industry-standard mechanisms and/or techniques that are:</p><ul><li>Provided by well-known and industry-accepted third-party suppliers; or</li><li>Designed and implemented in accordance with applicable industry standards or best practices.<strong></strong></li></ul></td><td rowspan="2"><p>Other methods, such as parameterization and output escaping, are better suited as primary defense mechanisms. While the type and complexity of the input data and how the data is expected to be used often dictate the methods that are most appropriate for a given input, parameterization should be used where possible. Output escaping can be used as an alternative if parameterization is not feasible. The use of input validation may be used as a secondary defense, where appropriate, to provide defense-indepth.</p><p>As is the case with other critical functions such as authentication and authorization, input protection methods should leverage industry-accepted thirdparty mechanisms where possible. If the use of such mechanisms is not feasible, then custom methods may be used if they are designed and implemented in accordance with applicable industry standards or best practices.</p></td></tr><tr><td><p><strong>C.3.2.1.c</strong> The assessor shall examine evidence and test the software to confirm that the implemented methods:</p><ul><li>Are implemented correctly in accordance with available guidance, and</li><li>Do not expose any vulnerabilities.</li></ul></td></tr><tr><td><p><strong>C.3.2.2</strong> Parsers and interpreters are configured with the most restrictive configuration feasible.<strong></strong></p></td><td><p><strong>C.3.2.2.a</strong> Using information obtained in Test Requirement C.3.2.b, the assessor shall examine evidence to identify the configurations for each parser or interpreter used to process untrusted input data.<strong></strong></p></td><td><p>In some cases, it may not be feasible to isolate (parameterization) or modify (escaping, encoding, etc.) input data prior to processing the data. In such cases, the only viable method to protect against input manipulation attacks is to use a parser or interpreter that has been hardened to prevent such attacks.</p><p>For example, at the time of this publication the only viable way to protect against an XML External Entity attack is to configure the XML parser to disable the Document Type Definition (DTD) feature, otherwise known as External Entities feature.</p><p><em>(continued on next page)</em></p></td></tr></tbody></table>

<table><tbody><tr><th><p><strong>Control Objectives</strong></p></th><th><p><strong>Test Requirements</strong></p></th><th><p><strong>Guidance</strong></p></th></tr><tr><td><p><strong></strong></p></td><td><p><strong>C.3.2.2.b</strong> For each of the parsers/interpreters and the configurations identified, the assessor shall examine evidence to confirm that parsers and interpreters are configured with the most restrictive set of capabilities feasible and that the settings are justified and reasonable.</p><p>Where certain parser/interpreter features cannot be configured securely, the assessor shall examine evidence to confirm that other methods are implemented to mitigate the lack of secure settings and to further protect against the execution of malicious commands.<strong></strong></p></td><td><p>The specific settings that must be disabled/enabled to protect against certain attacks depends on the parsers and interpreters. For more information, refer to available security guidance on the specific parsers/interpreters in use.</p><p>Where certain features of the parsers or interpreters cannot be configured with the most secure settings possible, then the processing of untrusted input data should use techniques such as sandboxing to prevent (or otherwise mitigate the impacts of) malicious code execution.</p></td></tr><tr><td rowspan="3"><p><strong>C.3.3</strong> Software security controls are implemented to protect software interfaces from resource starvation attacks.<strong></strong></p></td><td><p><strong>C.3.3.a</strong> Using information obtained in Test Requirements C.2.1.a and C.2.2, the assessor shall examine evidence to identify all Internet accessible interfaces and the functions and resources exposed (or potentially exposed) through those interfaces to identify where such interfaces, functions, and resources may be susceptible to resource starvation attacks.<strong></strong></p></td><td rowspan="3"><p>While the goal of many attacks is to expose sensitive data and sensitive functions (directly or indirectly) to unauthorized users, other attacks are intended to prevent an application’s use of or access to important computing resources.</p><p>Such attacks aim to overwhelm the software/system with requests or fill all available system resources such as processing time or memory, therefore starving the software/system of the resources it requires for normal operation and rendering it unusable to other users.</p><p>In other cases, these attacks are intended to force the software to behave in unintended ways which could, in turn, enable an attacker to execute arbitrary code on the targeted system or expose sensitive data through error messages.</p><p><em>(continued on next page)</em></p></td></tr><tr><td><p><strong>C.3.3.b</strong> Where such interfaces, functions, and resources are potentially susceptible to resource starvation attacks, the assessor shall examine evidence to confirm that:</p><ul><li>The threat of such attacks is documented in accordance with Control Objective 4.1, and</li><li>Software security controls to mitigate such attacks are documented and implemented in accordance with Control Objective 4.2.<strong></strong></li></ul></td></tr><tr><td><p><strong>C.3.3.c</strong> The assessor shall examine evidence to confirm that the software security controls implemented to mitigate resource starvation and other similar attacks on Internet accessible interfaces are designed and implemented in accordance with applicable industry standards and best practices.<strong></strong></p></td></tr></tbody></table>

<table><tbody><tr><th><p><strong>Control Objectives</strong></p></th><th><p><strong>Test Requirements</strong></p></th><th><p><strong>Guidance</strong></p></th></tr><tr><td><p><strong></strong></p></td><td><p><strong>C.3.3.d</strong> Where the implementation of software security controls is user configurable or otherwise requires user input or interaction, the assessor shall examine evidence to confirm that guidance is made available to stakeholders in accordance with Control Objective 12.1 that describes how to configure such mechanisms.<strong></strong></p></td><td><p>Examples of methods used to mitigate the risk of such attacks include limiting the rate on the number of requests that can be submitted within a given time period (rate limiting). Additional methods to prevent such attacks may include defining other limits such as the number of users and/or systems that can submit requests, mutually authenticating those users and systems, or using CAPTCHA or other antiautomation techniques that can prevent large volumes of requests being submitted to software interfaces within a short time period.</p><p>For SaaS or other similar environments, appropriate network-based controls may also be used to address these types of attacks.</p></td></tr><tr><td rowspan="3"><p><strong>C.3.4</strong> Software security controls are implemented to protect Internet accessible interfaces from malicious file content.<strong></strong></p></td><td><p><strong>C.3.4.a</strong> Using information obtained in Test Requirement C.2.1.a, the assessor shall examine evidence to identify all Internet accessible interfaces that accept file uploads and the file types permitted.<strong></strong></p></td><td rowspan="3"><p>File uploads can be used to provide larger datasets to a piece of software. However, such uploads must be managed securely to prevent the misuse of this function. Files not correctly managed may end up being executable on the host system or be used as a vector to infect or subvert the software or other systems (for example, by creating or overwriting malicious configuration files). File upload interfaces</p><p>may also provide unintended access to the underlying host system or software.</p><p>Different file types may be provided with different permissions or functions within a host system, and any file upload system should ensure that only expected file types are accepted for upload. However, care must be taken to ensure that this added process does not itself expose vulnerabilities that could be exploited.</p><p><em>(continued on next page)</em></p></td></tr><tr><td><p><strong>C.3.4.b</strong> Where the software accepts file uploads over Internet accessible interfaces, the assessor shall examine evidence to confirm that:</p><ul><li>The threat of attacks on file upload mechanisms is documented in accordance with Control Objective 4.1, and</li><li>Software security controls to mitigate such attacks are documented and implemented in accordance with Control Objective 4.2.<strong></strong></li></ul></td></tr><tr><td><p><strong>C.3.4.c</strong> The assessor shall examine evidence to confirm that the software security controls implemented to mitigate attacks on file upload mechanisms are implemented in accordance with applicable industry standards and best practices.<strong></strong></p></td></tr></tbody></table>

| **Control Objectives** | **Test Requirements** | **Guidance** |
| --- | --- | --- |
|     | **C.3.4.d** The assessor shall examine evidence to confirm that the software security controls implemented to mitigate attacks on file upload mechanisms include methods to restrict the file types permitted by the file upload mechanisms. | Many file formats allow for the embedding of other files or data which can be ‘expanded’ out when parsing the source file. In some scenarios this can be used to gain privileges or exploit vulnerabilities on the host platform which would not otherwise be possible. Uploaded files need to be managed in ways that prevent the exploitation of file parsing or expansion attacks.<br><br>To prevent the exploitation of file upload systems, any files that are uploaded cannot be assigned writable or executable privileges. Files which are required to be writable need to be copied across to a separate file managed only by the software to prevent a malicious user from exploiting the file between upload and use.<br><br>For defense-in-depth, some software development languages and frameworks include the ability to make calls to anti-malware systems to scan these files upon upload. For more information, refer to relevant third-party documentation.<br><br>File and file type parsers are notorious sources of exploits. Such parsers must not make security decisions based on file names or file extensions. Acceptable file types should have a basic structure that enables the software to determine the file type without using file names or file extensions. |
| **C.3.4.e** The assessor shall examine evidence to confirm that the software security controls implemented to mitigate attacks on file upload mechanisms include methods to restrict the maximum number and size of files permitted for upload. |
| **C.3.4.f** The assessor shall examine evidence to confirm that the software security controls implemented to mitigate attacks on file upload mechanisms account for the use of complex or compressed file formats that are often used to overwhelm or otherwise exploit file-parsing mechanisms. |
| **C.3.4.g** The assessor shall examine evidence to confirm that the software security controls implemented to mitigate attacks on file upload mechanisms include methods that store uploaded files outside of the webroot and assign those files read-only permissions. |
| **C.3.4.h** The assessor shall examine evidence to confirm that the use of file-parsing mechanisms does not rely on file names or file extensions for security purposes. |
| **C.3.4.i** Where the implementation of software security controls is user configurable or otherwise requires user input or interaction, the assessor shall examine evidence to confirm that guidance is made available to stakeholders in accordance with Control Objective 12.1 that describes how to configure such mechanisms. |

<table><tbody><tr><th><p><strong>Control Objectives</strong></p></th><th><p><strong>Test Requirements</strong></p></th><th><p><strong>Guidance</strong></p></th></tr><tr><td rowspan="6"><p><strong>C.3.5 </strong>Software security controls are implemented to protect Internet accessible interfaces from hostile object creation and data tampering.<strong></strong></p></td><td><p><strong>C.3.5.a </strong>Using information obtained in Test Requirements C.2.1.a and C.2.2, the assessor shall examine evidence to identify all software functions exposed through Internet accessible interfaces that accept and process data objects as inputs.<strong></strong></p></td><td rowspan="6"><p>Some software APIs accept serialized data objects (for example, arrays, cookies, tokens, and so on) to be passed from other systems. However, without appropriate methods in place to restrict object deserialization and creation, malicious individuals may be able to use these APIs to launch denial-ofservice attacks, compromise access control mechanisms, or inject and execute malicious code on underlying systems.</p><p>There are numerous methods to protect against serialization (and deserialization) attacks. Some programming languages, libraries, and APIs provide features and functions that are resistant to serialization attacks. Other methods include using deserialization mechanisms that only support pure data formats like JSON or XML, limiting data types allowed during object creation, encrypting communications, and authenticating API clients.</p><p>Appropriate methods to protect against serialization attacks depend on the API implementation. Refer to industry sources, such as the Open Web Application Security Project (OWASP) for more information.</p><p>For the same reasons explained in the last paragraph of guidance for Control Objective C.3.4, file-parsing mechanisms must not make security decisions based on file names or file extensions. Acceptable file types should have a basic structure that enables the software to determine the file type without using file names or file extensions.</p><p><em>(continued on next page)</em></p></td></tr><tr><td><p><strong>C.3.5.b</strong> Where the software accepts and processes data objects as inputs, the assessor shall examine evidence to confirm that:</p><ul><li>The threat of hostile object creation and data tampering attacks is documented in accordance with Control Objective 4.1, and</li><li>Software security controls to mitigate such attacks are documented and implemented in accordance with Control Objective 4.2.<strong></strong></li></ul></td></tr><tr><td><p><strong>C.3.5.c</strong> The assessor shall examine evidence to confirm that the software security controls implemented to mitigate hostile object creation and data tampering attacks are implemented in accordance with applicable industry standards and best practices.<strong></strong></p></td></tr><tr><td><p><strong>C.3.5.d</strong> The assessor shall examine evidence to confirm that the software security controls implemented to mitigate hostile object creation and data tampering attacks include methods that restrict the file formats permitted by file-parsing mechanisms.<strong></strong></p></td></tr><tr><td><p><strong>C.3.5.e</strong> The assessor shall examine evidence to confirm that the use of file-parsing mechanisms does not rely on file names or file extensions for security purposes.<strong></strong></p></td></tr><tr><td><p><strong>C.3.5.f</strong> The assessor shall examine evidence to confirm that the use of file-parsing mechanisms does not expose other vulnerabilities.<strong></strong></p></td></tr></tbody></table>

| **Control Objectives** | **Test Requirements** | **Guidance** |
| --- | --- | --- |
|     | **C.3.5.g** Where the software accepts serialized objects as inputs, the assessor shall examine evidence to confirm that software security controls are implemented to protect against deserialization attacks and that such security controls adhere to applicable industry standards and best practices. | Some file-parsing mechanisms are inherently susceptible to certain vulnerabilities. For example, XML parsers are often vulnerable to External Entity attacks. Similarly, JSON parsers are vulnerable to attacks where insecure commands, such as eval(), can enable the execution of malicious code.<br><br>To mitigate attacks that attempt to exploit vulnerabilities in file-parsing mechanisms, it may be necessary for entities to implement additional software security controls. Examples of such controls include, but are not limited to, configuring file-parsing mechanisms to use the most restrictive configuration feasible, avoiding or escaping certain commands that are known issues for file-parsing mechanisms, or isolating and executing file-parsing commands in a sandbox. The methods used to further mitigate such attacks should consider the specific parsers and interpreters in use and be implemented in a manner appropriate for each parser and interpreter. |
| **C.3.5.h** Where the software security controls implemented to protect against hostile object creation and data tampering are user configurable or otherwise require user input or interaction, the assessor shall examine evidence to confirm that guidance is made available to stakeholders in accordance with Control Objective 12.1 that describes how to configure such mechanisms. |
| **C.3.6** Software security controls are implemented to protect Internet accessible interfaces from attacks that exploit multi-origin resource sharing. | **C.3.6.a** The assessor shall examine evidence to determine if and/or how the software supports cross-origin access to Internet accessible interfaces, and to confirm that access to software APIs and resources from browser-based scripts is disabled by default. | Software may be required to allow access to resources or API interfaces from other domains or Internet origins. This practice may lead to vulnerabilities that expose sensitive data or sensitive functions to attacks.<br><br>Where not required, cross-origin resource sharing should be disabled. Where cross-origin resource sharing is necessary due to a legitimate business purpose, such access must be enabled only for the domains and origins required for the software to perform its intended function(s).<br><br>Use of permission lists or other configurations may be suitable for identifying permitted origins, but such configurations must also be protected against modification by malicious parties. |
| **C.3.6.b** Where cross-origin access is enabled, the assessor shall examine evidence to confirm that the reasons for enabling cross-origin access are reasonable and justified, and that access is restricted to the minimum number of origins feasible. |
| **C.3.6.c** The assessor shall test the software to confirm that the claims made by the assessed entity regarding cross-origin access are valid. At a minimum, testing is expected to include functional testing using forensic tools/techniques. |

| **Control Objectives** | **Test Requirements** | **Guidance** |
| --- | --- | --- |
|     | **C.3.6.d** Where disabling or restricting cross-origin access to software APIs requires user input or interaction, the assessor shall examine evidence to confirm that appropriate guidance on this process is provided to stakeholders in accordance with Control Objective 12.1. |     |

<table><tbody><tr><th><p><strong>Control Objectives</strong></p></th><th><p><strong>Test Requirements</strong></p></th><th><p><strong>Guidance</strong></p></th></tr><tr><td colspan="2"><p><strong>Control Objective C.4: Web Software Communications</strong></p><p>Sensitive data transmissions are secured in accordance with Control Objective 6.</p></td><td></td></tr><tr><td rowspan="2"><p><strong>C.4.1</strong> Sensitive data transmissions are encrypted in accordance with Control Objectives 6.2 and 6.3.<strong></strong></p></td><td><p><strong>C.4.1.a</strong> Using information obtained in Test Requirement 6.2.a, the assessor shall examine evidence to determine how communications are handled by the software, including those between separate systems in the overall software architecture.<strong></strong></p></td><td rowspan="2"><p>The types of data which may be considered sensitive may vary across different implementations. See Control Objective 1.1 for more information on identifying sensitive data.</p><p>It is therefore important that any connection that transmits sensitive data is encrypted using strong cryptography. Common methods for achieving this will include the use of TLS using appropriate cipher suites.</p><p>Although connections that do not transmit sensitive data do not explicitly require the use of encryption, it is noted that the use of strong cryptography to secure all connections is considered a best practice and should be implemented for all communications</p><p>unless legitimate business or technological constraints exist that render such an approach infeasible. In most cases, however, communications between web application components include the transmission of authentication information (user credentials or session information) which is considered sensitive data by definition and should therefore be encrypted using strong cryptography.</p></td></tr><tr><td><p><strong>C.4.1.b</strong> Where the software allows or otherwise supports the transmission of sensitive data between users and systems in different security contexts, the assessor shall examine evidence to confirm that all such communications are encrypted using strong cryptography in accordance with Control Objectives 6.2 and 6.3.<strong></strong></p></td></tr><tr><td><p><strong>Control Objectives</strong></p></td><td><p><strong>Test Requirements</strong></p></td><td><p><strong>Guidance</strong></p></td></tr><tr><td rowspan="2"><p><strong></strong></p></td><td><p><strong>C.4.1.c</strong> Where sensitive data is transmitted using server-toserver communications (for example, using APIs), the assessor shall examine evidence to confirm that the software enforces or otherwise supports mutual authentication between systems.<strong></strong></p></td><td><p>Where sensitive data is transmitted between systems operating within different security contexts and/or different environments, it is important that such communications be restricted to an explicitly approved list of systems, and that the systems involved be mutually authenticated such that attempts to intercept or compromise such communications are appropriately mitigated.</p><p>Where the software provider controls the configuration of such communications, mutual authentication must be enforced. Otherwise, the software provider must provide features to support the mutual authentication of disparate systems so that an implementing entity may configure such features accordingly.</p></td></tr><tr><td><p><strong>C.4.1.d</strong> Where internally generated or self-signed certificates are used for securing sensitive data transmissions, the assessor shall examine evidence to confirm that:</p><ul><li>The use of internally generated or self-signed certificates is reasonable and justified.</li><li>The software is configured to accept the minimum feasible number of internally generated or self-signed certificates.<strong></strong></li></ul></td><td><p>Many organizations that choose to use internally generated and/or self-signed certificates do so for the benefits they offer without considering the additional overhead needed to manage them securely. As a result, critical security processes such as certificate revocation and key management are not implemented or maintained properly. For this reason, the use of internally generated and/or selfsigned certificates should be kept to an absolute minimum. Where their use is required, such instances should be documented and justified.</p></td></tr></tbody></table>

1. Refer to the PCI Secure SLC Standard and its associated Program Guide for more information on Secure SLC qualification. [↑](#footnote-ref-1)

2. Sensitive authentication data must not be stored after authorization (even if encrypted). [↑](#footnote-ref-2)

3. Full track data from the magnetic stripe, equivalent data on the chip, or elsewhere. [↑](#footnote-ref-3)

4. The three- or four-digit value printed on the front or back of a payment card. [↑](#footnote-ref-4)

5. Personal identification number entered by cardholder during a card-present transaction, and/or encrypted PIN block present within the transaction message. [↑](#footnote-ref-5)